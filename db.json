{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/tranquilpeak/source/assets/css/jquery.fancybox.css","path":"assets/css/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/jquery.fancybox.js","path":"assets/js/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/thumbs.css","path":"assets/css/thumbs.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/thumbs.js","path":"assets/js/thumbs.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/all.css","path":"assets/css/all.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.eot","path":"assets/fonts/fa-brands-400.eot","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.svg","path":"assets/fonts/fa-brands-400.svg","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.ttf","path":"assets/fonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.woff","path":"assets/fonts/fa-brands-400.woff","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.eot","path":"assets/fonts/fa-regular-400.eot","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.svg","path":"assets/fonts/fa-regular-400.svg","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.woff2","path":"assets/fonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.ttf","path":"assets/fonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.woff","path":"assets/fonts/fa-regular-400.woff","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.woff2","path":"assets/fonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.eot","path":"assets/fonts/fa-solid-900.eot","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.svg","path":"assets/fonts/fa-solid-900.svg","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.ttf","path":"assets/fonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.woff","path":"assets/fonts/fa-solid-900.woff","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.woff2","path":"assets/fonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/gitalk.js","path":"assets/js/gitalk.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/gitment.js","path":"assets/js/gitment.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/jquery.js","path":"assets/js/jquery.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/gitment.css","path":"assets/css/gitment.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/algoliasearch.js","path":"assets/js/algoliasearch.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/moment-with-locales.js","path":"assets/js/moment-with-locales.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/gitalk.css","path":"assets/css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/tranquilpeak.css","path":"assets/css/tranquilpeak.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/tranquilpeak.js","path":"assets/js/tranquilpeak.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/cover-v1.2.0.jpg","path":"assets/images/cover-v1.2.0.jpg","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/cover.jpg","path":"assets/images/cover.jpg","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/logo-algolia-nebula-blue-full.svg","path":"assets/images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-bold-italic.ttf","path":"assets/fonts/merriweather-bold-italic.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-bold.ttf","path":"assets/fonts/merriweather-bold.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-light-italic.ttf","path":"assets/fonts/merriweather-light-italic.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-light.ttf","path":"assets/fonts/merriweather-light.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather.ttf","path":"assets/fonts/merriweather.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/open-sans-bold.ttf","path":"assets/fonts/open-sans-bold.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/fonts/open-sans.ttf","path":"assets/fonts/open-sans.ttf","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/style.css","path":"assets/css/style.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/script.js","path":"assets/js/script.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/css/style-xrypzi5utvjdggbat5gkdwxqbgttnkrvs7tlchsgv99hft5dd4siavxjhxz5.min.css","path":"assets/css/style-xrypzi5utvjdggbat5gkdwxqbgttnkrvs7tlchsgv99hft5dd4siavxjhxz5.min.css","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/js/script-xsbhvwgmrvs7y66t1asi0w8ljlicdyj3ltwbfxxzmdtzgdnpvch4jogtdj8b.min.js","path":"assets/js/script-xsbhvwgmrvs7y66t1asi0w8ljlicdyj3ltwbfxxzmdtzgdnpvch4jogtdj8b.min.js","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/p9.ico","path":"assets/images/p9.ico","modified":0,"renderable":1},{"_id":"themes/tranquilpeak/source/assets/images/cover1.jpg","path":"assets/images/cover1.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1597655468193},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1597655475510},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1597655475510},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1597655475510},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1597655475510},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1597655475510},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1597655475534},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1597655475510},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1597655475510},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1597655475510},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1597655475510},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1597655475510},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1597655475510},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1597655475510},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1597655475510},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1597655475510},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1597655475510},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1597655475510},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1597655475510},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1597655475534},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1597655475534},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1597655475534},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1597655475534},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1597655475534},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1597655475534},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1597655475534},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1597655475534},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1597655475534},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1597655475534},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1597655475534},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1597655475534},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1597655475534},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1597655475534},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1597655475554},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1597655475558},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1597655475558},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1597655475534},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1597655475534},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1597655475554},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1597655475554},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1597655475554},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1597655475554},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1597655475554},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1597655475554},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1597655475554},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1597655475554},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1597655475554},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1597655475554},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1597655475554},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1597655475554},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1597655475554},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1597655475554},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1597655475554},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1597655475558},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1597655475558},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1597655475554},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1597655475554},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1597655475558},{"_id":"source/_posts/Hello-Hexo.md","hash":"69636b023ff0b700fea481f7531e71fe31852176","modified":1597655634426},{"_id":"public/2020/08/17/Hello-Hexo/index.html","hash":"797213336ff64e8c88bcc755ba01f1afaa8813f0","modified":1597738217586},{"_id":"public/2020/08/17/hello-world/index.html","hash":"834d836b0b514868a1c2cd49b4d04c1e4672992b","modified":1597738217586},{"_id":"public/archives/index.html","hash":"b8e7d73b6ca8ee181565fc2d54f0804e579296a5","modified":1600504813954},{"_id":"public/archives/2020/index.html","hash":"5305caa062bf8ea1501162c18eff3194798c6171","modified":1600504813954},{"_id":"public/archives/2020/08/index.html","hash":"66c530a8ccad85d15b7fa52a756ef799953cce9c","modified":1597758529004},{"_id":"public/index.html","hash":"5e293a5012aa047241139b4dd36f34d2294e7029","modified":1600504813954},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1597655644743},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1597655644743},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1597655644743},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1597655644743},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1597655644743},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1597655644743},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1597655644743},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1597655644743},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1597655644743},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1597655644743},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1597655644743},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1597655644743},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1597655644743},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1597655644743},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1597655644743},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1597655644743},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1597655644743},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1597655644743},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1597655644743},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1597655644743},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1597655644743},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1597655644743},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1597655644743},{"_id":"themes/tranquilpeak/DOCUMENTATION.md","hash":"daaa36cff0cf7aeb7682372d6697a55d6a0f2f5b","modified":1586813095000},{"_id":"themes/tranquilpeak/Gruntfile.js","hash":"b2b078651cf8c5dcde2e847169ce242ad3319ca3","modified":1586813095000},{"_id":"themes/tranquilpeak/LICENSE","hash":"7a3b30ddb56760b35a6b7cd210aeb271cd292b60","modified":1586813095000},{"_id":"themes/tranquilpeak/README.md","hash":"c18f2fea9ceeec6efa85d892df67a191d6c84ec5","modified":1586813095000},{"_id":"themes/tranquilpeak/.eslintrc","hash":"ea1da9c0b0863a612ace47bd336cff95497bd878","modified":1586813095000},{"_id":"themes/tranquilpeak/.gitignore","hash":"19e27dd778896662e6d604b69411d2dc3cf5fec6","modified":1586813095000},{"_id":"themes/tranquilpeak/package.json","hash":"ce4b638a8739ddd323a3248ca1b7ae480388d70c","modified":1586813095000},{"_id":"themes/tranquilpeak/.eslintignore","hash":"1f78f00553adf9ee374b343191ed809b0f8ba073","modified":1586813095000},{"_id":"themes/tranquilpeak/renovate.json","hash":"f902d35646d7a6a637f727b02cd832c4339a4ca9","modified":1586813095000},{"_id":"themes/tranquilpeak/_config.yml","hash":"baddd77aa8be41a59bb011bfbd9c1752a5fb49e8","modified":1600137399978},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE.md","hash":"ec6bf3eb708f8eb62736ede6d2080f6610849802","modified":1586813095000},{"_id":"themes/tranquilpeak/.github/CONTRIBUTING.md","hash":"8873700e439b6fc8aa4804b70a90fd81bf310d6c","modified":1586813095000},{"_id":"themes/tranquilpeak/.github/PULL_REQUEST_TEMPLATE.md","hash":"03cdb93ca72cd6a19043ea4bb1ec4f5b7479a0a9","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/de-DE.yml","hash":"c9a7514af3c5c58023f8d3ed9503be4253146015","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/en.yml","hash":"1d8f8e3dd95dc67a1991898fc849323a1cf46ec3","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/es.yml","hash":"b5f37df87377d985339a21f343bf54db46926f1a","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/fa.yml","hash":"ec86c6fd655ed0c6df017c17f62b784b916d3a4a","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/fr-FR.yml","hash":"c644bb587a5360bb70a12c2d83f8d5973fb0055c","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/it-IT.yml","hash":"a5655d08a311f3292df5805ea2d6d72fd68726ca","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/ja.yml","hash":"3c6f7cda21ac91abc9f728e3093b1e98b42d5295","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/ko.yml","hash":"b56376775c5bc7f8f1d1b356340597cc61aae392","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/pt-br.yml","hash":"e2edf45fae5a5290a3dc2111ef38d5cd40d43771","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/ru.yml","hash":"262f781591cf2dd1584411ed4a780369d4d2e30a","modified":1586813095000},{"_id":"themes/tranquilpeak/languages/zh-cn.yml","hash":"003d1019e9d14c4783e7322831a243f4d71d3d04","modified":1597734496860},{"_id":"themes/tranquilpeak/languages/zh-tw.yml","hash":"f04e0e91edacb8f6cae7308007bd5e5158e6c77e","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/all-archives.ejs","hash":"28a4e97d1cfe4730dbcc8fde27b079320b5eec35","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/all-categories.ejs","hash":"c2257b8265a9a328e69c92f4a88cb2cdd99c047a","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/all-tags.ejs","hash":"aabb765f51a8d7582a5bafdbc8876b46ff1e6ea1","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/archive.ejs","hash":"0df1edf4ed40b316715ef1949b09aa9c98d22359","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/category.ejs","hash":"67902c418e299399133fe2a7ebc39cadd17de861","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/index.ejs","hash":"36e89b37f520533bef85fb32b714214257fad1d0","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/layout.ejs","hash":"29c1291c7ca3f5da7bee6385b7f716d179199933","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/page.ejs","hash":"ae761feddc98f4d3260e7591ed9fc91d9a49d0ab","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/post.ejs","hash":"ae761feddc98f4d3260e7591ed9fc91d9a49d0ab","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/tag.ejs","hash":"72bff1ae241fbe2ddca0537e8ed77c791a7d1766","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/.eslintrc.json","hash":"4cd7451f0bc15440bc8147912c63a11acd0e280f","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/pipeline.js","hash":"75b65cbd6d6ae471739ba80c9f792f602a0769d4","modified":1586813095000},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE/bug-report.md","hash":"b9a9ffe556f1fca39009403f87bb8c8e840dc369","modified":1586813095000},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE/feature-request---improvement.md","hash":"7d53b0c0d65dd28da17ff9d948e842883cab467f","modified":1586813095000},{"_id":"themes/tranquilpeak/.github/workflows/nodejs.yml","hash":"595c32bcb8ba72cd0737c6009f24dabda12af834","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/about.ejs","hash":"c92588fcb4435e19b8c7e10fe24484aa6639060e","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/cover.ejs","hash":"18b9a620fca9b648fd59467a66b3f4fdbba42613","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/footer.ejs","hash":"67962257d9e3cb6a4d56e3f0263f192ba9a413dd","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/google-analytics.ejs","hash":"b756aa731678a37d22c97c7dc30767331b08d109","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/head.ejs","hash":"cff295204908954f52c73111fca420cba48f7bc9","modified":1597722285395},{"_id":"themes/tranquilpeak/layout/_partial/baidu-analytics.ejs","hash":"736eca2ecf6fdeea032d47c02c51688f006cafb4","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/header.ejs","hash":"b1315ca70848602323f03659d9aba67a0586c028","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/index.ejs","hash":"34d9260021e4b8b4bf232c2786d8e90e0db5bd20","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/pagination.ejs","hash":"89d3be71ff2f5a847850d50e117896056f0ca1a6","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post.ejs","hash":"cdccf8f0ea1c01997fafdabb7cf044d3939cbb6c","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/filters/excerpt.js","hash":"5e0e473d46f8c7aac988ebf0b25ab2eab0af73bb","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/script.ejs","hash":"21017c82d1d26b52d0d0e768e79c3871cfc567af","modified":1597722285395},{"_id":"themes/tranquilpeak/scripts/filters/thumbnail_image_url.js","hash":"0ad2d9304c991e2989708bdbfa6a59030ee691d3","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/helpers/absolute_url.js","hash":"0d520a946b6f0abbac60529017ed3133265aac60","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/helpers/generate_sharing_link.js","hash":"89069677e8acddef5fba0d3093f5f73fde4fa485","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/helpers/is_remote_url.js","hash":"471237ea295bcc9a392a5bb6738ef4c6ab673afb","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/helpers/json_ld.js","hash":"4cd07766ed9436f0c4cb8a9ae22644272918b837","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/helpers/resolve_asset_url.js","hash":"c813e9daaed374b386b91876923f10c0cf1d624c","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/tags/alert.js","hash":"5b86358dd53c9b0d44c385ec12cf9e76383e229a","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/tags/highlight_text.js","hash":"8e093f21e9a4b10c19be6f300dc90bcc39685ec9","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/tags/fancybox.js","hash":"55ce02f9ef084f43932eb9b0f10db1d5e9c3a250","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/tags/image.js","hash":"ab6b04db8fe2ad21ec52dac5e1c3ee76400c6a79","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/tags/tabbed_codeblock.js","hash":"7dccd36bdd85c96eb7af125b30d634f44125700c","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/tags/video.js","hash":"497d64fd454cc6fd5c26a42cb8e38db90b83cf4f","modified":1586813095000},{"_id":"themes/tranquilpeak/scripts/tags/wide_image.js","hash":"d3596c62694548a3a684e8dfeb5372038ef6f450","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/search.ejs","hash":"0fd5f75117912cd1e6e7e6094079bccdc79c0000","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/sidebar.ejs","hash":"39fb0c9f214cc36f4f96cbcacc832e542d723881","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/archive.ejs","hash":"bdd73d1f70bd91533863943f940f8193d44e0fdd","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/tranquilpeak.scss","hash":"e69c62b19ece4ab35d992e163b47f2a8374d7611","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-bold-italic.ttf","hash":"c1b8593dc9ddbf1a1a6268d31e08c4041448ed76","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-bold.ttf","hash":"e6d0ffb2d0348d9e22de97e57214b7db795e9513","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-light-italic.ttf","hash":"c3835119c62e78a21cfb33e2de6686fb4a5929a0","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_fonts/merriweather-light.ttf","hash":"69bd3f15962cf91348a133d3d38571a5c67eca65","modified":1586813095000},{"_id":"themes/tranquilpeak/.github/ISSUE_TEMPLATE/question.md","hash":"443c4f27268d39e89390edb7dcffda407a070fd7","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_fonts/merriweather.ttf","hash":"d392237948e74246a2fb0d0d886498776a185e54","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_fonts/open-sans-bold.ttf","hash":"3823779db9f51a34658809ce66bdd6ed1145ed8e","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_fonts/open-sans.ttf","hash":"618b78a8f6ffe7e1998eab67268859e2ab54be8e","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_images/logo-algolia-nebula-blue-full.svg","hash":"d5e4426b6bd2d8b8c3f477f83d348d8f3b3ec1ca","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/.eslintrc.json","hash":"27d4e7223eee3eca7eb717bea2d28d35714eccbc","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/about.js","hash":"ce68bcc929192dfca6e699fe8e528990cd2d9590","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/archives-filter.js","hash":"8b8998b0e67c745a20450001c0739f6977b63309","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/categories-filter.js","hash":"a5f3c4b9bbef1c8ec881eb39551060ca95bfbb33","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/codeblock-resizer.js","hash":"391c2c9135579ea50c2060e0612e7105e06a8ff7","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/fancybox.js","hash":"659aaad375ecff9748a5d3b0ff1378a549236513","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/header.js","hash":"58ca619f851ebff35724c07dca7f1ed25e9cd5f2","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/image-gallery.js","hash":"90efc47246af69b7e17fab6e0bd1578043fcc2b0","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/post-bottom-bar.js","hash":"64f78c44d29d3559d5e14e436b8cfe1d24b8c965","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/search-modal.js","hash":"7ea9ab668bc3118c28e6212516f366ef764d3550","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/share-options.js","hash":"c2046697540786721ff7c4754774f94fcaf32696","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/sidebar.js","hash":"18dc623dd237c519bb79ce93283a5446cc11a487","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/smartresize.js","hash":"7342a21f94d7bb0525ccbd917d43a6824d7ae63e","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/tabbed-codeblocks.js","hash":"1282e11aacb036c8c9310cac49b75d7e2200125c","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_js/tags-filter.js","hash":"d33625df51d7b9788eeea338626f04387c96f053","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/config/clean.js","hash":"ea70743eb4ed0d9ead68d6fc8b65b9f936229a00","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/config/concat.js","hash":"0c2c4dbbfac52f20a3035a2f8cd1c24f1759b17e","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/config/copy.js","hash":"4b9a4e724c65ec71cfec36b387a2625fc0f1074c","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/config/cssmin.js","hash":"352185864437728c9c19169f4fec6fc3308e8b6d","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/config/replace.js","hash":"984ba7ed966c16b1fadf47c62f76e99940d4b12d","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/config/sails-linker.js","hash":"c1103119ec7d1f04cfbb1cda83b40d11e8f2d218","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/config/sass.js","hash":"84ba6be74f99c502543b7f77a105ce16931fd38e","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/config/sync.js","hash":"fbc09d0ed201993bc1918223b8f8ad5b68f50490","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/config/uglify.js","hash":"57c7341a004b61539f5b3f02bd772f40494b8306","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/config/watch.js","hash":"933eecd8a2506c627dbb9a1137305a16dd2d9f9a","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/register/build.js","hash":"f64c77127a2d4bfdbb9866fcf368913334f44603","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/register/buildProd.js","hash":"450ff77a1bf631d1799206d218c6468592a59862","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/register/default.js","hash":"80174db9b8a729980770e639e70999ce5a816b78","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/register/eslint.js","hash":"718cd8a80d060e2587b84e0e20ceaa39c2cc9411","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/register/linkAssets.js","hash":"079cd274cb29f9984eb7150d88f61819d2ef6235","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/archive-post.ejs","hash":"e19455749c5c1bf773214d965f173613dd8f30f6","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/register/linkAssetsProd.js","hash":"37f2fab80f25757be3e34b40bc5a26a82f088491","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/register/syncAssets.js","hash":"0813093c3e252a58371db53e914183a97e3186a1","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/actions.ejs","hash":"419223bff6146c46d4e993e4aa2e3636b051edc8","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/category.ejs","hash":"d4b26aa8c66aa8dbfae7a4aafed874745efb2f8e","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/disqus.ejs","hash":"9e0d238ed918e3138d5a9bb23a90408669e19169","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/duoshuo.ejs","hash":"992368f8863f34d1dccf90c0cabc33d5dcdbe92a","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/gallery.ejs","hash":"71b4ad77ab08c0980bf85b85c98a90c7de2be107","modified":1586813095000},{"_id":"themes/tranquilpeak/tasks/register/compileAssets.js","hash":"a65122ba0d1a1b6044e3b635a644882577b628ba","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/gitalk.ejs","hash":"8c91c60ffeab780a8a628145c572456187142101","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/gitment.ejs","hash":"1dcfdca4d20bab5a43bda44cf37df506ab3a0fb7","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/header-cover.ejs","hash":"4d3a73d0c6f26769f778d02a559e5055ef1ee0ca","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/header.ejs","hash":"19c5f0d680db08fe2880f41de3a085ef0298a386","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/share-options.ejs","hash":"896158d62beba2ecb7d6af6e0f01f8f1ea23e706","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/tag.ejs","hash":"2a52f38fa359f8ec8ae776e44e92c48795e31272","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/base/_base.scss","hash":"f0a46b090a0a4dd21edfd89095761895c5278ecb","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_alert.scss","hash":"1e6bf40de34a341dd0228357e288153b9292977c","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_archive.scss","hash":"cfdf53475d228643d5c5e62689b3c6a593e4ccce","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_box.scss","hash":"eebaacf55234fdaa156edb7dc4d9a4f382eaf4d4","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_button.scss","hash":"ea9bd41800fe04860f7e892c17010588b2563a06","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_caption.scss","hash":"dad2683f5f3235b335eebcbda3db59a1cfbb2283","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_code.scss","hash":"0a14fe197c221a4d4d91ee9d41541ce7969043ca","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_fancybox.scss","hash":"e162e2ecafc2be70238a9885fd57a9a7ad642757","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_figure.scss","hash":"9828521c34d91f04813db23e174708f510fe30bf","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_form.scss","hash":"368187e0c5f1a57d8c423f2ec23e897ee94a1a27","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_hide.scss","hash":"c2f5ed51086b9ea5d94ff548bdc4653ea5cd7912","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_highlight-text.scss","hash":"7a7a8a78f75d6c43a46fd020e2d44546e716751b","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_icon.scss","hash":"60dc972bcd81b4f95ab2c067ca910a5bf324d907","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_link.scss","hash":"7460155ebf7ce0d3e9acd090b6b99673127fd0be","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_image-gallery.scss","hash":"95ee5be04c523bf914596042574780ee527e6b38","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_main-content.scss","hash":"90c46c87289a8b3cf7c14d36900f5ced9db36c25","modified":1586813095000},{"_id":"themes/tranquilpeak/layout/_partial/post/meta.ejs","hash":"f13cb5089b0d5898c9606519d1c872725a63a5f9","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_markdown.scss","hash":"ba6d7e8f84b3b6dfef339f28b5c6ae372ead674f","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_media.scss","hash":"84aa03c01b741bbeb31c6b48122930f30ad40de3","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_modal.scss","hash":"bc56f823cd67b2ed65b5cf2c3e1851fa3e82f0f9","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_pagination.scss","hash":"809b9330a0e2d79c9285c1a452d61648248c8b70","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_post-actions.scss","hash":"1cc3ba46b1752043207bb820f4f886b0f982e445","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_post-header-cover.scss","hash":"c4bf950602ccb3fbdad54938979651a7b488236e","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_post.scss","hash":"0457c281b7893f8fde8a0590e4c1ff2ffb4bc1a6","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_postShorten.scss","hash":"a1b1ab16751fb99a3937cc0797426c658a2921f7","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_pullquote.scss","hash":"86bc35ba358d1340debc459a344f5f6d34acaa42","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_tag.scss","hash":"ddd1c2ce17f0116655bdacda598e7f1d6fd18262","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_share-options-bar.scss","hash":"f6289a7cce6efe039614c77085945923c32d9673","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_text.scss","hash":"7b38858248da2f73cf64c5949fd475a8e0a246ae","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_video.scss","hash":"f9727fd300d73e8844abf0e2575c45e6c7769333","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/components/_tooltip.scss","hash":"f33ad3e677761af1ceb42d337691b8b354ff70bd","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/layouts/_blog.scss","hash":"2450e07594a5e5186170fb5b5b157cc340808a9a","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/layouts/_about.scss","hash":"4a1c4cca6623449602208256dee6422173daf1ef","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/layouts/_cover.scss","hash":"03a951c9b35dd4e35456caa36950e6d6bef77ac3","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/layouts/_bottom-bar.scss","hash":"c7816c7ebc253d46466355860ead6669a3707ac6","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/layouts/_footer.scss","hash":"645161942c66e6afbd666b4755337a6a6261e5e0","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/layouts/_main.scss","hash":"ee4648502b355db51fc6cb7b05375003331f2f6e","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/layouts/_header.scss","hash":"d840a4be850cb258167ee1081e1b288dc64b3d2c","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/layouts/_sidebar.scss","hash":"facaff0ca816a4ace67c7689e4286e88eb1010c2","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/pages/_search.scss","hash":"5f7cde0b68156ea802c3caf6cd673cab948b09d9","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/themes/_hljs-custom.scss","hash":"a0ffab53db35bbd4881aeb077400cba55551f3bd","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/_fonts.scss","hash":"4da4074668be0e0abe756aa537a406d14da7ceff","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/themes/_hljs-tranquilpeak.scss","hash":"3c1e0d8b6e2f37820d00572878d060080c5a6fe7","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_bottom-bar.scss","hash":"ab28b4d66f021e44d7a46a76157c6a2b5fd23496","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/_variables.scss","hash":"fc62fcffcdb16fb823c3cb170bbcf34493f0467f","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_button.scss","hash":"70c64560144d7d6015bbedeca0531258f9bafa07","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_category.scss","hash":"8cfc45772365e537949a4cd20cfa2a79e1a75dc8","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_form.scss","hash":"14026f13b54ef9f2cd7109cf1bca43040816e542","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_header.scss","hash":"52de2cb5f49a3b5748557fe2d25791ce52457d62","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_main.scss","hash":"0ad55a6191d0a533917845006ceae329353c0b90","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_opacity.scss","hash":"cfc9905b6df3b5100a30b5c47fd331068f238f97","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_post-header-cover.scss","hash":"ecd9078372d8bd1b7f4979bae3251e8efb345a9b","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_prefix.scss","hash":"5e04cd54ba375f69c97b62b7d4e535118ec78177","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_share-options-bar.scss","hash":"06f84bceb82df4d3bda64144f6fe4ad8e3e45f89","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_tag.scss","hash":"c8a87e586e27f999ffa46f273f78a812f1cf2f0a","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_css/utils/mixins/_sidebar.scss","hash":"6c3dc034c3d5fdf7f0c4c39a6913f5bae4fc4767","modified":1586813095000},{"_id":"themes/tranquilpeak/package-lock.json","hash":"b16b710fe54258616f29cc821afdb6b2f01727ad","modified":1586813095000},{"_id":"themes/tranquilpeak/source/_images/cover.jpg","hash":"04328470ad699ee1979d703ef41841439530383f","modified":1597801429258},{"_id":"themes/tranquilpeak/source/_images/cover-v1.2.0.jpg","hash":"df915f5b3eeed6bad93a183f65e5c6f536e551fe","modified":1597801224424},{"_id":"themes/tranquilpeak/source/assets/css/jquery.fancybox.css","hash":"00ce8430edb0a4ca35e08a9813e039d3a4b7868c","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/jquery.fancybox.js","hash":"048f1f8464eba59ccc706250693bc2ab060098a9","modified":1597722282502},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.eot","hash":"af1d634a307219795957412a586abaf626f4829b","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.ttf","hash":"bb89a35e00d0ba8a5382cc66809abe3d5cd3e932","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.woff","hash":"dc2741902e041fc638697d76733b6252c68f1f99","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.woff","hash":"3023db69a482111f7a17f29cee621a933cc5f4b9","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.woff2","hash":"3a175545f961094f3614f208f2166187b642355f","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.eot","hash":"e6feaa7a93ad42acb348529c9a684a0cf5cbf2ee","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.ttf","hash":"d9b2f287f46c950737c434e4153777968a73cecc","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.svg","hash":"53983550b89268aff9bbe00cbde3ef423c00716f","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-brands-400.svg","hash":"8730dd14f32b5c64c935b7d0d583589703fc6dd7","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/images/logo-algolia-nebula-blue-full.svg","hash":"d5e4426b6bd2d8b8c3f477f83d348d8f3b3ec1ca","modified":1597722282602},{"_id":"themes/tranquilpeak/source/assets/images/cover.jpg","hash":"04328470ad699ee1979d703ef41841439530383f","modified":1597801434478},{"_id":"themes/tranquilpeak/source/assets/images/cover-v1.2.0.jpg","hash":"df915f5b3eeed6bad93a183f65e5c6f536e551fe","modified":1597801301272},{"_id":"themes/tranquilpeak/source/assets/css/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/css/gitment.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1597722282526},{"_id":"themes/tranquilpeak/source/assets/css/thumbs.css","hash":"133acf84f948218219d3f23eb466fe54aceda97d","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-regular-400.woff2","hash":"37b761c26708037d19664cebea70416852487087","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-bold-italic.ttf","hash":"c1b8593dc9ddbf1a1a6268d31e08c4041448ed76","modified":1597722282602},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-bold.ttf","hash":"e6d0ffb2d0348d9e22de97e57214b7db795e9513","modified":1597722282602},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-light-italic.ttf","hash":"c3835119c62e78a21cfb33e2de6686fb4a5929a0","modified":1597722282602},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather-light.ttf","hash":"69bd3f15962cf91348a133d3d38571a5c67eca65","modified":1597722282602},{"_id":"themes/tranquilpeak/source/assets/fonts/open-sans-bold.ttf","hash":"3823779db9f51a34658809ce66bdd6ed1145ed8e","modified":1597722282602},{"_id":"themes/tranquilpeak/source/assets/fonts/merriweather.ttf","hash":"d392237948e74246a2fb0d0d886498776a185e54","modified":1597722282602},{"_id":"themes/tranquilpeak/source/assets/fonts/open-sans.ttf","hash":"618b78a8f6ffe7e1998eab67268859e2ab54be8e","modified":1597722282602},{"_id":"themes/tranquilpeak/source/assets/js/thumbs.js","hash":"ee9a65e280178b9525441b751ad7c0e6eb887022","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/tranquilpeak.js","hash":"ed9d93b9de4037c97c8699b7b9b985ec48c1b25d","modified":1597722282614},{"_id":"themes/tranquilpeak/source/assets/css/all.css","hash":"5244302dc004caa8d255a74db305ca3308a33b67","modified":1597722282610},{"_id":"themes/tranquilpeak/source/assets/css/tranquilpeak.css","hash":"fccd55b879d432eeba95c58fecb4c1f7e78fdb83","modified":1597722282614},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.woff","hash":"120dab7a8a93da819ab3025da6a9f3d3ccd65cce","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.woff2","hash":"af776f52d579da211590e0691d554b88a69dfe61","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.ttf","hash":"481530e4da272092a90415b3403b4e533416e295","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1597722282522},{"_id":"themes/tranquilpeak/source/assets/css/style-xrypzi5utvjdggbat5gkdwxqbgttnkrvs7tlchsgv99hft5dd4siavxjhxz5.min.css","hash":"9a48b4ab6421c394fa299f75e53f52f203b8031b","modified":1597722283158},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.eot","hash":"e13aaeda706af85d9382d7c39f5a3f79d612cd31","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/script-xsbhvwgmrvs7y66t1asi0w8ljlicdyj3ltwbfxxzmdtzgdnpvch4jogtdj8b.min.js","hash":"7ae95cfeeaa668775d426aa5e7f6aea91569215a","modified":1597722285391},{"_id":"themes/tranquilpeak/source/assets/css/style.css","hash":"b0ab5c4db42e22edac04fa05bb887e2ea46d04f2","modified":1597722282618},{"_id":"themes/tranquilpeak/source/assets/js/jquery.js","hash":"7faa15a054093f3b5d674e63b6567c835a6fa217","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/script.js","hash":"a8a3124ad02f5ba5fb75ff916c1d804405bdb01c","modified":1597722282630},{"_id":"themes/tranquilpeak/source/assets/js/gitalk.js","hash":"adfac600bc92ac1714874ac6022bb5bfffe0161c","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/js/moment-with-locales.js","hash":"67e795cf9f15093505f4886267f1ba0d234659e9","modified":499162500000},{"_id":"themes/tranquilpeak/source/assets/fonts/fa-solid-900.svg","hash":"cae06b2de99cc3f05225d54eb630352dc40dc6ef","modified":499162500000},{"_id":"source/all-categories/index.md","hash":"3d47d4e31035e3c8d960730f36bd3ad27f88e9be","modified":1597729907008},{"_id":"source/all-tags/index.md","hash":"a9092fa374dd3f5b8b5c72f02fa0b128309f91ed","modified":1597729993656},{"_id":"source/all-archives/index.md","hash":"634c7e0b6841e3cdbb53b62fc5db80e1ad3a69f2","modified":1597730053305},{"_id":"themes/tranquilpeak/source/assets/images/p9.ico","hash":"fab9684be8686e1f5cfec33548f774b71e00df1f","modified":1597733100524},{"_id":"themes/tranquilpeak/source/_images/p9.ico","hash":"fab9684be8686e1f5cfec33548f774b71e00df1f","modified":1597733212367},{"_id":"source/_posts/My-New-Post.md","hash":"85352fb060201fe4dfc46778d5d17da2a36baa13","modified":1597735783929},{"_id":"public/all-categories/index.html","hash":"a6438db5b9c4c9c65916aeb03645d985db273df5","modified":1600504813954},{"_id":"public/all-tags/index.html","hash":"d6c5d9dbb99b5125429745e0f3d51ee68f35e4b1","modified":1600504813954},{"_id":"public/all-archives/index.html","hash":"5929c05b6bba581b5e1b9385cbf37a2efab9d8e1","modified":1600504813954},{"_id":"public/2020/08/10/My-New-Post/index.html","hash":"207cfb514966a7c39b872ebbe2519e824d89095c","modified":1597738217586},{"_id":"public/assets/fonts/fa-regular-400.eot","hash":"af1d634a307219795957412a586abaf626f4829b","modified":1597738217586},{"_id":"public/assets/fonts/fa-regular-400.ttf","hash":"bb89a35e00d0ba8a5382cc66809abe3d5cd3e932","modified":1597738217586},{"_id":"public/assets/fonts/fa-regular-400.woff","hash":"dc2741902e041fc638697d76733b6252c68f1f99","modified":1597738217586},{"_id":"public/assets/fonts/fa-regular-400.woff2","hash":"37b761c26708037d19664cebea70416852487087","modified":1597738217586},{"_id":"public/assets/images/logo-algolia-nebula-blue-full.svg","hash":"d5e4426b6bd2d8b8c3f477f83d348d8f3b3ec1ca","modified":1597738217586},{"_id":"public/assets/fonts/merriweather-bold-italic.ttf","hash":"c1b8593dc9ddbf1a1a6268d31e08c4041448ed76","modified":1597738217586},{"_id":"public/assets/fonts/merriweather-bold.ttf","hash":"e6d0ffb2d0348d9e22de97e57214b7db795e9513","modified":1597738217586},{"_id":"public/assets/fonts/merriweather-light-italic.ttf","hash":"c3835119c62e78a21cfb33e2de6686fb4a5929a0","modified":1597738217586},{"_id":"public/assets/fonts/merriweather-light.ttf","hash":"69bd3f15962cf91348a133d3d38571a5c67eca65","modified":1597738217586},{"_id":"public/assets/fonts/merriweather.ttf","hash":"d392237948e74246a2fb0d0d886498776a185e54","modified":1597738217586},{"_id":"public/assets/fonts/open-sans-bold.ttf","hash":"3823779db9f51a34658809ce66bdd6ed1145ed8e","modified":1597738217586},{"_id":"public/assets/fonts/open-sans.ttf","hash":"618b78a8f6ffe7e1998eab67268859e2ab54be8e","modified":1597738217586},{"_id":"public/assets/fonts/fa-brands-400.woff","hash":"3023db69a482111f7a17f29cee621a933cc5f4b9","modified":1597738217586},{"_id":"public/assets/fonts/fa-brands-400.woff2","hash":"3a175545f961094f3614f208f2166187b642355f","modified":1597738217586},{"_id":"public/assets/fonts/fa-solid-900.woff","hash":"120dab7a8a93da819ab3025da6a9f3d3ccd65cce","modified":1597738217586},{"_id":"public/assets/fonts/fa-solid-900.woff2","hash":"af776f52d579da211590e0691d554b88a69dfe61","modified":1597738217586},{"_id":"public/assets/images/p9.ico","hash":"fab9684be8686e1f5cfec33548f774b71e00df1f","modified":1597738217586},{"_id":"public/assets/fonts/fa-brands-400.eot","hash":"e6feaa7a93ad42acb348529c9a684a0cf5cbf2ee","modified":1597738217586},{"_id":"public/assets/fonts/fa-brands-400.ttf","hash":"d9b2f287f46c950737c434e4153777968a73cecc","modified":1597738217586},{"_id":"public/assets/fonts/fa-regular-400.svg","hash":"53983550b89268aff9bbe00cbde3ef423c00716f","modified":1597738217586},{"_id":"public/assets/css/thumbs.css","hash":"3673ba1f616738f588fe887863846a958343b970","modified":1597738217586},{"_id":"public/assets/js/thumbs.js","hash":"1dacca749bad458211a886d3bcbbeb4600aaceac","modified":1597738217586},{"_id":"public/assets/fonts/fa-solid-900.eot","hash":"e13aaeda706af85d9382d7c39f5a3f79d612cd31","modified":1597738217586},{"_id":"public/assets/fonts/fa-solid-900.ttf","hash":"481530e4da272092a90415b3403b4e533416e295","modified":1597738217586},{"_id":"public/assets/css/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1597738217586},{"_id":"public/assets/css/gitment.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1597738217586},{"_id":"public/assets/css/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1597738217586},{"_id":"public/assets/images/cover.jpg","hash":"04328470ad699ee1979d703ef41841439530383f","modified":1597802899700},{"_id":"public/assets/js/tranquilpeak.js","hash":"ed9d93b9de4037c97c8699b7b9b985ec48c1b25d","modified":1597738217586},{"_id":"public/assets/images/cover-v1.2.0.jpg","hash":"df915f5b3eeed6bad93a183f65e5c6f536e551fe","modified":1597801322393},{"_id":"public/assets/css/all.css","hash":"5244302dc004caa8d255a74db305ca3308a33b67","modified":1597738217586},{"_id":"public/assets/css/tranquilpeak.css","hash":"fccd55b879d432eeba95c58fecb4c1f7e78fdb83","modified":1597738217586},{"_id":"public/assets/js/gitment.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1597738217586},{"_id":"public/assets/js/jquery.fancybox.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1597738217586},{"_id":"public/assets/js/script-xsbhvwgmrvs7y66t1asi0w8ljlicdyj3ltwbfxxzmdtzgdnpvch4jogtdj8b.min.js","hash":"7ae95cfeeaa668775d426aa5e7f6aea91569215a","modified":1597738217586},{"_id":"public/assets/css/style-xrypzi5utvjdggbat5gkdwxqbgttnkrvs7tlchsgv99hft5dd4siavxjhxz5.min.css","hash":"9a48b4ab6421c394fa299f75e53f52f203b8031b","modified":1597738217586},{"_id":"public/assets/fonts/fa-brands-400.svg","hash":"8730dd14f32b5c64c935b7d0d583589703fc6dd7","modified":1597738217586},{"_id":"public/assets/js/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":1597738217586},{"_id":"public/assets/fonts/fa-solid-900.svg","hash":"cae06b2de99cc3f05225d54eb630352dc40dc6ef","modified":1597738217586},{"_id":"public/assets/css/style.css","hash":"d052a703bbd272dd4f4b4184671d20b4033f4e7b","modified":1597738217586},{"_id":"public/assets/js/jquery.js","hash":"7faa15a054093f3b5d674e63b6567c835a6fa217","modified":1597738217586},{"_id":"public/assets/js/gitalk.js","hash":"0dc919ab7e5da764e4ed3cb1e27078691fec156d","modified":1597738217586},{"_id":"public/assets/js/script.js","hash":"e80fd7908bd121b3058f5528c57cccefe1f7c20f","modified":1597738217586},{"_id":"public/assets/js/moment-with-locales.js","hash":"67e795cf9f15093505f4886267f1ba0d234659e9","modified":1597738217586},{"_id":"source/_posts/来了老弟.md","hash":"654eb3ed84d3ebb46661657680e176e7eb2940d2","modified":1597740340153},{"_id":"public/2020/08/18/来了老弟/index.html","hash":"f76eeb3d69417e61d531639ffbedc94599ab1cc5","modified":1597740022855},{"_id":"public/archives/2016/index.html","hash":"a0b4f0e39abc3b835096dda1749513c9d0344c44","modified":1597750930584},{"_id":"public/archives/2016/04/index.html","hash":"107e8fbff4e8ea4d1832be5e724d980a644530a6","modified":1597750930584},{"_id":"public/categories/技术/index.html","hash":"aa9ded895b09e37f7783d3bf7b890b51776cc450","modified":1600504813954},{"_id":"public/tags/Markdown/index.html","hash":"4c2ef0abbe8e2e24db60472f9cdf69560303068b","modified":1597758529004},{"_id":"public/2016/04/14/来了老弟/index.html","hash":"9055ad894dbe7b916f495914aa6cc9d6e0e21ef5","modified":1597740343805},{"_id":"source/_posts/认识Markdown.md","hash":"944f2888d9dcaeeddd473eb9a38a22db6b845548","modified":1597758440239},{"_id":"public/2016/04/14/认识Markdown/index.html","hash":"e099d376d37243358e1fa8ee7ca425e4f94ef2d8","modified":1597751195154},{"_id":"source/_posts/demo.md","hash":"5b08217bc131c1395902d2e57d341a6ec3d88a2a","modified":1597758456559},{"_id":"public/2020/08/18/demo/index.html","hash":"0093ea7678400fab8c203f2cc4bab3b308981323","modified":1597741903329},{"_id":"source/_posts/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1597741380493},{"_id":"public/2016/04/14/demo/index.html","hash":"76f1e6f5ca4bdfe3f7b84257a238020f17450d0c","modified":1597742071967},{"_id":"public/2018/04/14/demo/index.html","hash":"b8c9eeb2a63f639d07a749199dd8036ca5d5f2f9","modified":1597758529004},{"_id":"public/archives/2018/index.html","hash":"179364abd07ab01d40e56bdbf954fd54de29fdbf","modified":1600504813954},{"_id":"public/archives/2018/04/index.html","hash":"8ea2e28da0109ca292b5f520c9d9c71614bf3816","modified":1600504813954},{"_id":"source/_posts/js判断终端类型.md","hash":"c0f43fe6977661e6d09614d6a214cb036d19f46b","modified":1600504754081},{"_id":"source/_posts/demo/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1597752497070},{"_id":"public/2018/04/14/js判断终端类型/index.html","hash":"9151bedf1c8810a8418fc4e7ff12d4895f41ba5f","modified":1600504813954},{"_id":"public/tags/js/index.html","hash":"d4906232c647615c4062e88cd988189e0b9a88eb","modified":1600504813954},{"_id":"public/2020/08/18/认识Markdown/index.html","hash":"7e0d1501bebc4cf58bf5ce90870fa462d2fb91af","modified":1600137045208},{"_id":"public/2018/04/14/demo/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1597753472878},{"_id":"public/2023/04/14/demo/index.html","hash":"62f20a1799eb5968bd8721d6f37a30acb0e8016f","modified":1597753440647},{"_id":"public/archives/2023/index.html","hash":"79961ade4436c82d99d6a04e39b87e0e2fa779c4","modified":1600137756544},{"_id":"public/archives/2023/04/index.html","hash":"5d085d058bb90a9fd8317bddf321f39e67315868","modified":1600137756544},{"_id":"public/2023/04/14/demo/cover-v1.2.0.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1597753440647},{"_id":"public/2023/04/14/js判断终端类型/index.html","hash":"4710c86643d177df341cf7003698e86aae5cff5f","modified":1600137756544},{"_id":"source/_posts/科学上网.md","hash":"f64492887c84817b7f6f4945de1f7fe0a93c0050","modified":1597758435302},{"_id":"public/2023/04/14/科学上网/index.html","hash":"a658178141ae9b15fdf1bab209767108e4822186","modified":1600137108468},{"_id":"themes/tranquilpeak/source/_images/cover1.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1597801396749},{"_id":"themes/tranquilpeak/source/assets/images/cover1.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1597801399919},{"_id":"public/assets/images/cover1.jpg","hash":"a98b9bf4d6be3af0156c0b6e781f067e343a682d","modified":1597802899700},{"_id":"source/_posts/rowKey.md","hash":"a1424149c85a53ff4cad11c9cbd31db9c311305f","modified":1600137830210},{"_id":"public/2020/09/14/rowKey/index.html","hash":"dcf6daeb1bb55cf4144940e34d18a7bafd787625","modified":1600157606537},{"_id":"public/archives/2020/09/index.html","hash":"4b5afbac62e02f67efa4215e1013fd4181006d47","modified":1600504813954},{"_id":"public/categories/测试/index.html","hash":"9aeaf9cd1affdcd5114973b1b5008e072907a56c","modified":1600157606537},{"_id":"public/tags/test/index.html","hash":"a87f3414a4a93633bf03da8aa00298707fa259f1","modified":1600157606537},{"_id":"source/_posts/es6整理.md","hash":"4e7f86b2975aa115b744e92b7f4e945d58f40581","modified":1600504738125},{"_id":"public/categories/笔记/index.html","hash":"ccc7203488f9fc7a48bb3bbaaaf972397a6cec2a","modified":1600504813954},{"_id":"public/2020/09/14/es6整理/index.html","hash":"6780a647001291f8632fca7b871e8631502aef6d","modified":1600504813954}],"Category":[{"name":"技术","_id":"ckdzoqe000000mqlgbb9643ny"},{"name":"测试","_id":"ckf3cpfgj0001wwlg7wftdrma"},{"name":"笔记","_id":"ckf9f34do000145lg57hxdrgu"}],"Data":[],"Page":[{"title":"all-categories","layout":"all-categories","comments":0,"_content":"","source":"all-categories/index.md","raw":"---\ntitle: \"all-categories\"\nlayout: \"all-categories\"\ncomments: false\n---\n","date":"2020-08-18T05:51:47.008Z","updated":"2020-08-18T05:51:47.008Z","path":"all-categories/index.html","_id":"ckdzj50js000020lg0olacqaq","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"all-tags","layout":"all-tags","comments":0,"_content":"","source":"all-tags/index.md","raw":"---\ntitle: \"all-tags\"\nlayout: \"all-tags\"\ncomments: false\n---\n","date":"2020-08-18T05:53:13.656Z","updated":"2020-08-18T05:53:13.656Z","path":"all-tags/index.html","_id":"ckdzj6spm0000h0lgcmz5dtsf","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""},{"title":"all-archives","layout":"all-archives","comments":0,"_content":"","source":"all-archives/index.md","raw":"---\ntitle: \"all-archives\"\nlayout: \"all-archives\"\ncomments: false\n---\n","date":"2020-08-18T05:54:13.305Z","updated":"2020-08-18T05:54:13.305Z","path":"all-archives/index.html","_id":"ckdzjakdz0000txlg6b9abdhq","content":"","site":{"data":{}},"thumbnailImageUrl":null,"excerpt":"","more":""}],"Post":[{"title":"判断终端类型","date":"2018-04-14T01:47:13.000Z","disqusIdentifier":"fdsF34ff34","keywords":["javascript"],"clearReading":true,"thumbnailImage":"https://res.cloudinary.com/ddb5vwne6/image/upload/v1597758372/timg_fy8o3h.jpg","thumbnailImagePosition":"left","autoThumbnailImage":"yes","metaAlignment":"center","coverImage":"cover-v1.2.0.jpg","coverCaption":"A beautiful sunrise","coverMeta":"out","coverSize":"partial","comments":0,"meta":false,"actions":false,"_content":"处理兼容时常常需要判断终端类型\n\n<!--excerpt-->\n{% codeblock %}\nvar u = navigator.userAgent;\nvar isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1; //android终端\nvar isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端\nvar agent = navigator.userAgent.toLowerCase();\nvar isMac = /macintosh|mac os x/i.test(navigator.userAgent);\nif (agent.indexOf(\"win32\") >= 0 || agent.indexOf(\"wow32\") >= 0) {\nconsole.log(Windows32)\n}\nif (agent.indexOf(\"win64\") >= 0 || agent.indexOf(\"wow64\") >= 0) {\nconsole.log(Windows63)\n}\nif (isMac && !u.match(/AppleWebKit.*Mobile.*/)) {\nconsole.log(mac)\n}\nif (isAndroid) {\nconsole.log(android)\n}\nif (isiOS && !!u.match(/AppleWebKit.*Mobile.*/)) {\nconsole.log(ios)\n}\n{% endcodeblock %}","source":"_posts/js判断终端类型.md","raw":"---\ntitle: 判断终端类型\ndate: 2018-04-14 09:47:13\ntags:\n    - js\ncategories:\n    - 技术\n##tranquilpeak添加的属性\ndisqusIdentifier: fdsF34ff34\nkeywords:\n- javascript\nclearReading: true\nthumbnailImage: https://res.cloudinary.com/ddb5vwne6/image/upload/v1597758372/timg_fy8o3h.jpg\nthumbnailImagePosition: left\nautoThumbnailImage: yes\nmetaAlignment: center\ncoverImage: cover-v1.2.0.jpg\ncoverCaption: \"A beautiful sunrise\"\ncoverMeta: out\ncoverSize: partial\ncomments: false\nmeta: false\nactions: false\n---\n处理兼容时常常需要判断终端类型\n\n<!--excerpt-->\n{% codeblock %}\nvar u = navigator.userAgent;\nvar isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1; //android终端\nvar isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端\nvar agent = navigator.userAgent.toLowerCase();\nvar isMac = /macintosh|mac os x/i.test(navigator.userAgent);\nif (agent.indexOf(\"win32\") >= 0 || agent.indexOf(\"wow32\") >= 0) {\nconsole.log(Windows32)\n}\nif (agent.indexOf(\"win64\") >= 0 || agent.indexOf(\"wow64\") >= 0) {\nconsole.log(Windows63)\n}\nif (isMac && !u.match(/AppleWebKit.*Mobile.*/)) {\nconsole.log(mac)\n}\nif (isAndroid) {\nconsole.log(android)\n}\nif (isiOS && !!u.match(/AppleWebKit.*Mobile.*/)) {\nconsole.log(ios)\n}\n{% endcodeblock %}","slug":"js判断终端类型","published":1,"updated":"2020-09-19T08:39:14.081Z","_id":"ckdzwln0g0000lnlgcrxie09b","layout":"post","photos":[],"link":"","content":"<!--excerpt-->\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var u &#x3D; navigator.userAgent;</span><br><span class=\"line\">var isAndroid &#x3D; u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Adr&#39;) &gt; -1; &#x2F;&#x2F;android终端</span><br><span class=\"line\">var isiOS &#x3D; !!u.match(&#x2F;\\(i[^;]+;( U;)? CPU.+Mac OS X&#x2F;); &#x2F;&#x2F;ios终端</span><br><span class=\"line\">var agent &#x3D; navigator.userAgent.toLowerCase();</span><br><span class=\"line\">var isMac &#x3D; &#x2F;macintosh|mac os x&#x2F;i.test(navigator.userAgent);</span><br><span class=\"line\">if (agent.indexOf(&quot;win32&quot;) &gt;&#x3D; 0 || agent.indexOf(&quot;wow32&quot;) &gt;&#x3D; 0) &#123;</span><br><span class=\"line\">console.log(Windows32)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (agent.indexOf(&quot;win64&quot;) &gt;&#x3D; 0 || agent.indexOf(&quot;wow64&quot;) &gt;&#x3D; 0) &#123;</span><br><span class=\"line\">console.log(Windows63)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (isMac &amp;&amp; !u.match(&#x2F;AppleWebKit.*Mobile.*&#x2F;)) &#123;</span><br><span class=\"line\">console.log(mac)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (isAndroid) &#123;</span><br><span class=\"line\">console.log(android)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (isiOS &amp;&amp; !!u.match(&#x2F;AppleWebKit.*Mobile.*&#x2F;)) &#123;</span><br><span class=\"line\">console.log(ios)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"thumbnailImageUrl":"https://res.cloudinary.com/ddb5vwne6/image/upload/v1597758372/timg_fy8o3h.jpg","excerpt":"<p>处理兼容时常常需要判断终端类型</p>","more":"<p>处理兼容时常常需要判断终端类型</p>\n<!--excerpt-->\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var u &#x3D; navigator.userAgent;</span><br><span class=\"line\">var isAndroid &#x3D; u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Adr&#39;) &gt; -1; &#x2F;&#x2F;android终端</span><br><span class=\"line\">var isiOS &#x3D; !!u.match(&#x2F;\\(i[^;]+;( U;)? CPU.+Mac OS X&#x2F;); &#x2F;&#x2F;ios终端</span><br><span class=\"line\">var agent &#x3D; navigator.userAgent.toLowerCase();</span><br><span class=\"line\">var isMac &#x3D; &#x2F;macintosh|mac os x&#x2F;i.test(navigator.userAgent);</span><br><span class=\"line\">if (agent.indexOf(&quot;win32&quot;) &gt;&#x3D; 0 || agent.indexOf(&quot;wow32&quot;) &gt;&#x3D; 0) &#123;</span><br><span class=\"line\">console.log(Windows32)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (agent.indexOf(&quot;win64&quot;) &gt;&#x3D; 0 || agent.indexOf(&quot;wow64&quot;) &gt;&#x3D; 0) &#123;</span><br><span class=\"line\">console.log(Windows63)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (isMac &amp;&amp; !u.match(&#x2F;AppleWebKit.*Mobile.*&#x2F;)) &#123;</span><br><span class=\"line\">console.log(mac)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (isAndroid) &#123;</span><br><span class=\"line\">console.log(android)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (isiOS &amp;&amp; !!u.match(&#x2F;AppleWebKit.*Mobile.*&#x2F;)) &#123;</span><br><span class=\"line\">console.log(ios)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"es6整理","date":"2020-09-14T01:47:13.000Z","disqusIdentifier":"fdsF34ff34","keywords":["javascript"],"clearReading":true,"thumbnailImage":"https://res.cloudinary.com/ddb5vwne6/image/upload/v1597758372/timg_fy8o3h.jpg","thumbnailImagePosition":"bottom","autoThumbnailImage":"yes","metaAlignment":"center","coverImage":"cover-v1.2.0.jpg","coverCaption":"A beautiful sunrise","coverMeta":"out","coverSize":"partial","comments":0,"meta":false,"actions":false,"_content":"ECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。\n\n<!--excerpt-->\n**ECMAScript2015**\n\n# 摘要\n\n#### 1.新的标准规范\n\nECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。\n\n#### 2.ECMAScript 和 js 关系\n\nECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。javascript 是 netscape 创 造的并交给了国际标准化组织 ECMA，之所以不叫做 JavaScript 由于商标的问题，java 是 sun 公司的商标，根据 授权协议只有 Netscape 公司可以合法使用 JavaScript 这个名字，另外就是为了体现 JavaScript 的标准的制定者 不是 ECMA 所以取名为 ECMAScript。\n\n#### 3.ES6 与 ECMAScript 2015 的关系\n\nES6 是 ECMA 的为 JavaScript 制定的第 6 个版本的标准，标准委员会最终决定，标准在每年的 6 月份正式发布一 次，作为当年的正式版本。ECMAscript 2015 是在 2015 年 6 月份发布的 ES6 的第一个版本。依次类推 ECMAscript 2016 是 ES6 的第二个版本、 ECMAscript 2017 是 ES6 的第三个版本……\n\n# 块级作用域\n\n#### 1.块级作用域的种类\n\nECMAScript2015 为 js 提出的第三个作用域，凡是带{}的都是一个块级作用域。\n\nif 语句的{},for 循环中的{},while 中的{},或者是我们单独写的{} try{}catch(error){}这些都提供了块级作用域。\n\n#### 块级作用域分析\n\n##### 1.为什么需要块级作用域？\n\n- 内层变量会覆盖外层变量\n\n  ```js\n  var lagou = \"拉勾\";\n  function fn() {\n    console.log(lagou); //undefined\n    if (false) {\n      var lagou = \"hello\";\n    }\n  }\n  fn();\n  ```\n\n这是因为 fn 函数体内以及有 var 声明的变量 lagou，只是还没有赋值，默认为 undefined。\n\n- 用来计数的循环变量泄露为全局变量\n\n  ```js\n  for (var i = 0; i < 10; i++) {}\n  // 10\n  console.log(i);\n  ```\n\n##### 2.块级作用域的成员\n\n块级作用域内的成员需要使用 let 或 const 命令定义的变量。\n\n```js\nvar lagou = \"拉勾\";\nfunction fn() {\n  console.log(lagou); //拉勾\n  if (true) {\n    let lagou = \"hello\";\n  }\n}\nfn();\n```\n\n# let const\n\n#### 1.let\n\n基本用法\n\nECMAScript2015 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。\n\nlet 主要声明块级作用域下的成员，这个成员变量的作用域范围只能在当前块级作用域下。\n\n- wer\n- er\n\n#### 2.const\n\nconst 声明变量的同时必须要赋值。\n\nconst 声明之后，不允许去修改它的值，这里面的值说的是不允许修改它，是声明之后不允许重新指向一个新\n\n的内存地址，可以去修改内存地址中的属性成员。\n\n# 数组\n\n#### 1.数组的解构\n\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。\n\n- 完全解构 将数组中的每一个值都对应上相应的变量。\n\n  ```js\n  var arr = [\"lagou\", \"edu\", \"web\"];\n  let [com, ind, work] = arr;\n  console.log(work); //web\n  ```\n\n- 不完全解构 数组中的部分值对应上了相应的变量。\n\n  ```js\n  var arr = [\"lagou\", \"edu\", \"web\"];\n  let [, , work] = arr;\n  console.log(work); //web\n  ```\n\n  注意:模式没有匹配上的可以不填，但是必须要加逗号隔开。\n\n* 扩展运算符...\n\n  - 展开运算符说明\n\n    - 三个点(…)是一个展开运算符，其功能为对三个点后面的变量进行展开操作\n\n    - 三个点(…)展开运算符:只能对具有 Iterator 接口的对象进行展开操作\n\n    - 使用场景\n\n          ![image-20200508180111209](imgs/image-20200508180111209.png)\n\n          案例一\n\n          ```js\n\n      var arr=[\"拉勾\",\"edu\",\"web\"];\n      fn(...arr)//web\n      `案例二`js\n      let a = [88,99,100];\n      let b = [101,102,103];\n      a.push(...b);\n      console.log(a);//[88, 99, 100, 101, 102, 103]\n      `案例三`js\n      let d={\n      e:\"拉钩教育\",\n      f:\"www.lagou.com\"\n      }\n      let obj={\n      g:\"web\",\n      h:1100,\n      ...d\n      };\n      console.log(obj);\n      {g: \"web\", h: 1100, e: \"拉钩教育\", f: \"www.lagou.com\"}\n      `案例四`js\n      var st=\"拉钩 edu\";\n      var arr=[...st];\n      console.log(arr)//[\"拉\", \"钩\", \"e\", \"d\", \"u\"]\n      `掌握了展开运算符的使用规则，我们看一下数组的特殊解构。`js\n      let [a,...b] = [1,2,3,4,5,6];\n      console.log(a)//1\n      console.log(b)//[2,3,4,5,6]\n\n      ```\n\n      ```\n\n* 解构不成功\n\n  右边的变量的个数超过了等号左边中数组的元素\n\n  ```js\n  let [a, b, c] = [12];\n  console.log(b); //undefined\n  ```\n\n  如果解构没有成功，则变量的值是 undefined，如果是展开运算的变量则是空数组。\n\n  ```javascript\n  let [a, b, ...c] = [12];\n  console.log(c); //[]\n  ```\n\n#### 2.数组的扩展\n\n- 扩展运算符...\n\n  - 扩展运算符（spread）是三个点（`...`）它好比<a href=\"#rest\"> rest 参数的逆运算</a>，将一个数组转为用逗号分隔的参数序列。\n\n  - 替代 apply()的使用技巧\n\n    我们之前在求一个数组中的最大值得时候采用得方式是 Math.max.apply(null,[12,34,56,43]) ==56\n\n    ```js\n    var max = Math.max.apply(null, [12, 34, 56, 43]);\n    console.log(max); //56\n    var max2 = Math.max(...[12, 34, 56, 43]);\n    console.log(max2); //56\n    ```\n\n- Array 类的扩展方法\n\n  - Array.from()\n\n  Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）\n\n  ```js\n  var arraylike = {\n    0: \"lagou\",\n    1: \"edu\",\n    2: \"web\",\n    length: 3,\n  };\n  var arr = Array.from(arraylike);\n  [\"lagou\", \"edu\", \"web\"];\n  ```\n\n  Array.from 还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组\n\n  ```js\n  var arr = Array.from([1, 2, 3], function (x) {\n    return x * x;\n  });\n  console.log(arr); //[1,4,9]\n  ```\n\n  - Array.of 方法用于将一组值，转换为数组，这个方法的主要目的，是弥补数组构造函数`Array()`的不足。因为参数个数的不同，会导致`Array()`的行为有差异。\n\n    ```js\n    var arr = Array(3); //[emptyx3]\n    ```\n\n    这里面 3 表示数组中元素的长度。\n\n    ```js\n    var arr = Array(2, 3, 4); //[2,3,4]\n    ```\n\n    当`Array()`里的参数个数大于 1 的时候，表示的是数组元素。\n\n    `Array.of()`方法不管里面参数的个数多少，都将其转为数组的元素。\n\n    ```js\n    var arr = Array.of(3);\n    console.log(arr); //[3]\n    ```\n\n# 对象\n\n#### 1.对象中有关变量的解构赋值\n\n解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\n```js\nlet { name, work } = { name: \"lagou\", work: \"web\" };\nconsole.log(name, work); //lagou web\n```\n\n#### 2.对象的扩展\n\n- 对象的简写\n\n  - 当变量名和属性名同名式，省略同名的属性值\n\n    ```js\n    const foo = \"bar\";\n    const baz = { foo };\n    // 等同于\n    const baz = { foo: foo };\n    ```\n\n- 省略方法中的 function\n\n  ```js\n  const obj = {\n    method() {\n      return \"拉勾!\";\n    },\n  };\n  // 等同于\n  const obj = {\n    method: function () {\n      return \"拉勾!\";\n    },\n  };\n  ```\n\n  - 属性的赋值器（setter）和取值器（getter）\n\n    ```js\n    const lagou = {\n      name: \"拉勾\",\n      get com() {\n        return this.name;\n      },\n      set work(value) {\n        this.name = this.name + value;\n      },\n    };\n    console.log(lagou.com); //拉勾\n    lagou.work = \"招聘\";\n    console.log(lagou.name); //拉勾招聘\n    ```\n\n  - 属性名表达式\n\n    es5 中定义对象的属性有两种方法，一种是用标识符做属性，一种是用表达式做属性\n\n    ```js\n    方法一;\n    obj.name = \"拉勾\";\n    // 方法二\n    obj[\"name\"] = \"拉勾\";\n\n    var lagou = {\n      name: \"拉勾\",\n    };\n    ```\n\n    如果使用大括号定义对象，那么在 es5 中只能使用标识符定义属性。\n\n    ```js\n    var lagou = {\n      name: \"拉勾\",\n    };\n    ```\n\n    但是 ECMAScript2015 在使用大括号定义对象的时候，允许使用表达式定义属性，把表达式放在方括号中。\n\n    ```js\n    let name = \"lagou\";\n    const lagou = {\n      [name]: \"web\",\n    };\n    console.log(lagou); //{lagou: \"web\"}\n    ```\n\n#### 3.三点运算在对象中的用途\n\n- 用于对象的解构\n\n  - 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。\n\n    ```js\n    let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\n    console.log(z); //{a: 3, b: 4}\n    ```\n\n    上面代码中，变量`z`是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（`a`和`b`），将它们连同值一起拷贝过来。\n\n        注意:1.解构赋值必须是最后一个参数。2.解构赋值的拷贝是浅拷贝。\n\n- 用于扩展运算\n\n  - 对象的扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\n    ```js\n    let z = { name: \"lagou\", work: \"web\" };\n    let n = { ...z };\n    n; // { name: \"lagou\", work: \"web\" }\n    ```\n\n# 字符串\n\n#### 1.字符串模板\n\n- 传统的字符串里不能使用换行符，必须使用转义符\\n 替代，字符串模板里可以使用。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\n\n- 模板字符串中嵌入变量，需要将变量名写在`${}`之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性\n\n  ```js\n  var name = \"拉勾\";\n  var st = `欢迎来到${name}`;\n  console.log(st);\n  ```\n\n#### 2.标签模板\n\n- 模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能。\n\n  ```js\n  console.log`hello`;\n  等同于;\n  console.log([\"hello\"]);\n  ```\n\n  标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。\n\n  注意:如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。\n\n  ```js\n  var name=\"laogou\";\n  var work=\"web\"\n  function tag(st,a,b){\n      console.log(st);\n      console.log(a);\n      console.log(b)\n      return \"hello lagou\";\n  }\n  var st=tag`hello${name},职业${work}开发`\n  console.log(st)//hello lagou\n  [\"hello\", \",职业\", \"开发\", raw: Array(3)]\n  laogou\n  web\n  ```\n\n  函数内的返回值，就是`tag`函数处理模板字符串后的返回值。\n\n  ```js\n  var name = \"laogou\";\n  var work = \"web\";\n  function tag(st, a, b) {\n    console.log(st);\n    console.log(a);\n    console.log(b);\n    return \"hello lagou\"; //如果没有返回值，则默认是undefined\n  }\n  var st = tag`hello${name},职业${work}开发`;\n  console.log(st); //hello lagou\n  ```\n\n#### 3.扩展的方法\n\n- 字符串实例的方法\n\n  - **includes()**\n\n    返回布尔值，表示是否找到了参数字符串\n\n    ```javascript\n    var st = \"lagou web\";\n    var b = st.includes(\"web\");\n    console.log(b); //true\n    ```\n\n  - **startsWith()**\n\n    返回布尔值，表示参数字符串是否在原字符串的头部\n\n    ```javascript\n    var st = \"lagou web\";\n    var b = st.startsWith(\"la\");\n    console.log(b); //true\n    ```\n\n  - **endsWith()**\n\n    返回布尔值，表示参数字符串是否在原字符串的尾部\n\n    ```javascript\n    var st = \"lagou web\";\n    var b = st.endsWith(\"web\");\n    console.log(b); //true\n    ```\n\n# 函数\n\n#### 参数默认值\n\n- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\n  ```javascript\n  function fn(a, b = \" lagou \") {\n    console.log(a + b);\n  }\n  fn(\"hello\"); //hello lagou\n  ```\n\n- 注意:\n\n  - 参数变量是默认声明的，所以不能用`let`或`const`再次声明.\n  - 使用参数默认值时，函数不能有同名参数\n\n- 参数默认值的位置\n\n  - 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。\n\n    ```javascript\n    function f(x = 1, y) {\n      return [x, y];\n    }\n\n    f() // [1, undefined]\n    f(2) // [2, undefined]\n    f(, 1) // 报错\n    ```\n\n#### <span name=\"app\">rest 参数</span>\n\n- ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\n  ```javascript\n  function add(...values) {\n    console.log(values);\n  }\n  add(2, 5, 3); // [2, 5, 3]\n  ```\n\n- rest 参数和函数中的参数解构有什么区别\n\n  - rest 参数是发生在函数的定义阶段，函数的额参数解构是发生在函数的调用阶段\n  - 二者是一种互为逆运算\n\n```javascript\nfunction add(...values) {\n  //这是rest参数\n  console.log(values);\n}\nadd(2, 5, 3); // [2, 5, 3]\nvar arr = [1, 2, 3];\nfunction fn(a, b, c) {\n  console.log(a + b + c);\n}\nfn(...arr); //6  这是参数的解构\n```\n\n#### 箭头函数\n\n- ES6 允许使用“箭头”（`=>`）定义函数。\n\n```javascript\nvar f = (v) => v;\n// 等同于\nvar f = function (v) {\n  return v;\n};\n```\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\n\n```javascript\nvar f = () => 5;\n// 等同于\nvar f = function () {\n  return 5;\n};\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function (num1, num2) {\n  return num1 + num2;\n};\n```\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回。\n\n```javascript\nvar sum = (num1, num2) => {\n  return num1 + num2;\n};\n```\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\n\n```javascript\nlet getItem = id => { id: id, name: \"Temp\" }; //报错\n\nlet getItem = id => ({ id: id, name: \"Temp\" });//不报错\n```\n\n- 箭头函数有几个使用注意点\n  - 函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数外面的 this 是什么，箭头函数内的 this 还是什么。\n  - 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n  - 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n\n```javascript\nvar name=\"web\"\nvar obj={\n    name:\"lagou\",\n    fn(){\n        var t=setTimeout(function(){\n            console.log(this.name)//web  this是window\n        },1000)\n    }\n}\nobj.fn()\n-----------------------------------\nvar name=\"web\"\nvar obj={\n    name:\"lagou\",\n    fn(){\n        var t=setTimeout(()=>{\n            console.log(this.name)//lagou this是obj\n        },1000)\n    }\n}\nobj.fn()\n```\n\n# Object\n\n#### Object.assign()\n\n- `Object.assign`方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n\n  ```javascript\n  const target = {\n    a: 123,\n    b: 123,\n  };\n  const sourcel = {\n    a: 456,\n    c: 456,\n  };\n  const result = Object.assign(target, sourcel);\n  console.log(target); //{a: 456, b: 123, c: 456}\n  console.log(target === result); //true\n  ```\n\n  如果目标对象与源对象有同名属性，则后面的属性会覆盖前面的属性。且`assign()`的返回值就是第一个对象。\n\n  如果有多个源对象有同名属性，依然是后面的会覆盖前面的属性\n\n  ```javascript\n  const target = { a: 1, b: 1 };\n  const source1 = { b: 2, c: 2 };\n  const source2 = { c: 3 };\n  Object.assign(target, source1, source2);\n  target; // {a:1, b:2, c:3}\n  ```\n\n- 利用`Object.assign()`复制一个对象，且其中一个对象的修改不会影响到另一个对象\n\n  ```javascript\n  const sourcel = {\n    a: 123,\n  };\n  var obj = Object.assign({}, sourcel);\n  obj.a = 456;\n  console.log(obj); //{a: 456}\n  console.log(sourcel); //{a: 123}\n  ```\n\n#### Object.is()\n\n- `Object.is`就是用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\n\n  ES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\n\n  ```js\n  console.log(Object.is(+0, -0)); //false\n  console.log(+0 === -0); //true\n  console.log(Object.is(NaN, NaN)); //true\n  console.log(NaN === NaN); //false\n  ```\n\n# Proxy\n\n#### 概述\n\nProxy 可以理解成一个快递员，我们发快递还是接受快递，都需要这个快递员充当一个代理的作用。ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例，这个实例就是一个代理对象（快递员）。\n\n```js\nvar proxy = new Proxy(target, handler);\n```\n\n#### 目标对象\n\n这个代理对象有两个参数，一个是代理的目标对象，第二个也是一个对象，它是配置对象，用来定制代理的拦截行为。\n\n```js\nconst person = {\n  name: \"zce\",\n  age: 20,\n};\nconst personProxy = new Proxy(person, {\n  get(target, property) {\n    console.log(target, property); //person{name:\"zce\",age:20}\n    return 100;\n  },\n  set() {},\n});\n```\n\n#### 配置对象\n\n- 配置对象中一般有两个方法`get`和`set`,`get`是用来拦截对目标对象属性的访问请求。`get`方法中有两个参数，第一个参数是目标对象，第二个参数是访问的那个属性。\n\n  ```js\n  const person = {\n    name: \"zce\",\n    age: 20,\n  };\n  const personProxy = new Proxy(person, {\n    get(target, property) {\n      console.log(target, property);\n      return 100;\n    },\n    set() {},\n  });\n\n  console.log(personProxy.name); //100\n  ```\n\n注意，这个`get`方法的返回值就是我们获取的这个属性的返回值。\n\n- 这个`get`方法中有三个参数，一个是代理的目标对象，一个是代理的处理对象，第三个参数是 proxy 实例本身，且第三个参数是可选参数。\n\n  ```js\n  const person = {\n    name: \"zce\",\n    age: 20,\n  };\n  const personProxy = new Proxy(person, {\n    get(target, property, o) {\n      console.log(o); //proxy{name:\"zec\",age:20}\n      return property in target ? target[property] : undefined;\n    },\n    set() {},\n  });\n\n  console.log(personProxy.age); //20\n  ```\n\n- 这个`set`方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选\n\n  ```js\n  const person = {\n    name: \"zce\",\n    age: 20,\n  };\n  const personProxy = new Proxy(person, {\n    get(target, property, o) {\n      return property in target ? target[property] : undefined;\n    },\n    set(obj, pro, value, o) {\n      console.log(obj, pro, value, o);\n    },\n  });\n\n  console.log((personProxy.name = \"zhang\"));\n  //{name: \"zce\", age: 20} \"name\" \"zhang\" Proxy {name: \"zce\", age: 20}\n  ```\n\n  可以去设置一些属性或修改\n\n  ```js\n  const person = {\n    name: \"zce\",\n    age: 20,\n  };\n  const personProxy = new Proxy(person, {\n    get(target, property, o) {\n      return property in target ? target[property] : undefined;\n    },\n    set(target, pro, value, o) {\n      //可以做一些内部校验\n      target[pro] = value;\n    },\n  });\n  console.log((personProxy.name = \"lagou\"));\n  person; //{name:\"lagou\",age:20}\n  ```\n\n# Reflect\n\n#### 概述\n\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\n\n- 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法\n\n- 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`\n\n  ```js\n  // 老写法\n  try {\n    Object.defineProperty(target, property, attributes);\n    // success\n  } catch (e) {\n    // failure\n  }\n\n  // 新写法\n  if (Reflect.defineProperty(target, property, attributes)) {\n    // success\n  } else {\n    // failure\n  }\n  ```\n\n- 让`Object`操作都变成函数行为。某些`Object`操作是命令式，比如`name in obj`和`delete obj[name]`，而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了函数行为。\n\n  ```js\n  // 老写法\n  \"assign\" in Object; // true\n\n  // 新写法\n  Reflect.has(Object, \"assign\"); // true\n  ```\n\n#### 静态方法\n\n- Reflect.get\n\n  - `Reflect.get(target, name, receiver)`,`Reflect.get`方法查找并返回`target`对象的`name`属性，如果没有该属性，则返回`undefined`\n\n    ```js\n    var myObject = {\n      foo: 1,\n      bar: 2,\n      get baz() {\n        return this.foo + this.bar;\n      },\n    };\n\n    Reflect.get(myObject, \"foo\"); // 1\n    Reflect.get(myObject, \"bar\"); // 2\n    Reflect.get(myObject, \"baz\"); // 3\n    ```\n\n  - 如果`name`属性部署了读取函数（getter），则读取函数的`this`绑定`receiver`。\n\n    ```js\n    var myObject = {\n      foo: 1,\n      bar: 2,\n      get baz() {\n        return this.foo + this.bar;\n      },\n    };\n\n    var myReceiverObject = {\n      foo: 4,\n      bar: 4,\n    };\n\n    Reflect.get(myObject, \"baz\", myReceiverObject); // 8\n    ```\n\n  - 如果第一个参数不是对象，`Reflect.get`方法会报错。\n\n    ```js\n    Reflect.get(1, \"foo\"); // 报错\n    Reflect.get(false, \"foo\"); // 报错\n    ```\n\n- Reflect.set\n\n  - `Reflect.set(target, name, value, receiver)`,`Reflect.set`方法设置`target`对象的`name`属性等于`value`\n\n    ```js\n    var myObject = {\n      foo: 1,\n    };\n\n    myObject.foo; // 1\n\n    Reflect.set(myObject, \"foo\", 2);\n    myObject.foo; // 2\n    ```\n\n  - 如果`name`属性设置了赋值函数，则赋值函数的`this`绑定`receiver`。\n\n    ```js\n    var myObject = {\n      foo: 4,\n      set bar(value) {\n        return (this.foo = value);\n      },\n    };\n\n    var myReceiverObject = {\n      foo: 0,\n    };\n\n    Reflect.set(myObject, \"bar\", 1, myReceiverObject);\n    myObject.foo; // 4\n    myReceiverObject.foo; // 1\n    ```\n\n- Reflect.has\n\n  - `Reflect.has(obj, name)`,`Reflect.has`方法对应`name in obj`里面的`in`运算符\n\n    ```js\n    var myObject = {\n      foo: 1,\n    };\n\n    // 旧写法\n    \"foo\" in myObject; // true\n\n    // 新写法\n    Reflect.has(myObject, \"foo\"); // true\n    ```\n\n    如果`Reflect.has()`方法的第一个参数不是对象，会报错。\n\n- Reflect.deleteProperty\n\n  - Reflect.deleteProperty(obj, name),`Reflect.deleteProperty`方法等同于`delete obj[name]`，用于删除对象的属性\n\n    ```js\n    const myObj = { foo: \"bar\" };\n\n    // 旧写法\n    delete myObj.foo;\n\n    // 新写法\n    Reflect.deleteProperty(myObj, \"foo\");\n    ```\n\n    该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回`true`；删除失败，被删除的属性依然存在，返回`false`。如果`Reflect.deleteProperty()`方法的第一个参数不是对象，会报错.\n\n# Promise\n\n#### 概述\n\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\n\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n#### promise 特点\n\n`Promise`对象有以下两个特点。\n\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。\n\n#### promise 使用方法\n\n- ES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。\n\n- `Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n  ```js\n  var p = new Promise(function (resolve, reject) {\n    if (true) {\n      resolve(data);\n    } else {\n      reject(data);\n    }\n  });\n  ```\n\n  `resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；`reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n- `Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。\n\n  ```js\n  p.then(\n    function (value) {\n      // success业务处理\n    },\n    function (error) {\n      // failure\n    }\n  );\n  ```\n\n  `then`方法可以接受两个回调函数作为参数。第一个回调函数是`Promise`对象的状态变为`resolved`时调用，第二个回调函数是`Promise`对象的状态变为`rejected`时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受`Promise`对象传出的值作为参数。\n\n  - 看一个简单的例子\n\n    ```js\n    function time(ms) {\n      return new Promise((resolve, reject) => {\n        setTimeout(resolve, ms);\n      });\n    }\n    time(1000).then((value) => {\n      console.log(value);\n    });\n    ```\n\n* Promise 新建后就会立即执行。\n\n  ```js\n  let promise = new Promise(function (resolve, reject) {\n    console.log(\"Promise\");\n    resolve();\n  });\n\n  promise.then(function () {\n    console.log(\"resolved.\");\n  });\n\n  console.log(\"Hi!\");\n  //Promise\n  //Hi\n  //resolved\n  ```\n\n# class\n\n#### 概述\n\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过`class`关键字，可以定义类。基本上，ES6 的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的`class`改写，就是下面这样。\n\n```js\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return \"(\" + this.x + \", \" + this.y + \")\";\n  }\n}\n```\n\n#### 基本介绍\n\n- `constructor()`\n\n  - `constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。\n\n- 类的实例\n\n  - 生成类的实例的写法，与 ES5 完全一样，也是使用`new`命令。前面说过，如果忘记加上`new`，像函数那样调用`Class`，将会报错。\n\n    ```js\n    class Point {\n      // ...\n    }\n    // 报错\n    var point = Point(2, 3);\n    // 正确\n    var point = new Point(2, 3);\n    ```\n\n  - 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。\n\n    ```js\n    class Point {\n      constructor(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n\n      toString() {\n        return \"(\" + this.x + \", \" + this.y + \")\";\n      }\n    }\n\n    var point = new Point(2, 3);\n\n    point.toString(); // (2, 3)\n\n    point.hasOwnProperty(\"x\"); // true\n    point.hasOwnProperty(\"y\"); // true\n    point.hasOwnProperty(\"toString\"); // false\n    point.__proto__.hasOwnProperty(\"toString\"); // true\n    ```\n\n  - 与 ES5 一样，类的所有实例共享一个原型对象\n\n    ```js\n    var p1 = new Point(2, 3);\n    var p2 = new Point(3, 2);\n\n    p1.__proto__ === p2.__proto__;\n    //true\n    ```\n\n* getter 和 setter\n\n  - 与 ES5 一样，在“类”的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\n    ```js\n    class MyClass {\n      constructor() {\n        // ...\n      }\n      get prop() {\n        return \"getter\";\n      }\n      set prop(value) {\n        console.log(\"setter: \" + value);\n      }\n    }\n\n    let inst = new MyClass();\n\n    inst.prop = 123;\n    // setter: 123\n\n    inst.prop;\n    // 'getter'\n    ```\n\n* 属性表达式\n\n  - 类的属性名，可以采用表达式\n\n    ```js\n    let methodName = \"getArea\";\n\n    class Square {\n      constructor(length) {\n        // ...\n      }\n\n      [methodName]() {\n        // ...\n      }\n    }\n    ```\n\n    上面代码中，`Square`类的方法名`getArea`，是从表达式得到的\n\n#### static\n\n- 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”\n\n  ```js\n  class Foo {\n    static classMethod() {\n      return \"hello\";\n    }\n  }\n\n  Foo.classMethod(); // 'hello'\n\n  var foo = new Foo();\n  foo.classMethod();\n  // TypeError: foo.classMethod is not a function\n  ```\n\n  解说：上面代码中，`Foo`类的`classMethod`方法前有`static`关键字，表明该方法是一个静态方法，可以直接在`Foo`类上调用（`Foo.classMethod()`），而不是在`Foo`类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\n- 注意，如果静态方法包含`this`关键字，这个`this`指的是类，而不是实例\n\n  ```js\n  class Foo {\n    static bar() {\n      this.baz();\n    }\n    static baz() {\n      console.log(\"hello\");\n    }\n    baz() {\n      console.log(\"world\");\n    }\n  }\n\n  Foo.bar(); // hello\n  ```\n\n  解说：上面代码中，静态方法`bar`调用了`this.baz`，这里的`this`指的是`Foo`类，而不是`Foo`的实例，等同于调用`Foo.baz`。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\n\n- 父类的静态方法，可以被子类继承\n\n  ```js\n  class Foo {\n    static classMethod() {\n      return \"hello\";\n    }\n  }\n\n  class Bar extends Foo {}\n\n  Bar.classMethod(); // 'hello'\n  ```\n\n- 静态属性\n\n  静态属性指的是 Class 本身的属性，即`Class.propName`，而不是定义在实例对象（`this`）上的属性\n\n  ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个[提案](https://github.com/tc39/proposal-class-fields)提供了类的静态属性，写法是在实例属性的前面，加上`static`关键字。\n\n  ```js\n  class MyClass {\n    static myStaticProp = 42;\n\n    constructor() {\n      console.log(MyClass.myStaticProp); // 42\n    }\n  }\n  ```\n\n#### 继承\n\n- 简介\n\n  - Class 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\n\n    ```js\n    class Point {}\n\n    class ColorPoint extends Point {}\n    ```\n\n    解说：上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类\n\n  - 子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类自己的`this`对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用`super`方法，子类就得不到`this`对象。\n\n    ```javascript\n    class Point {\n      /* ... */\n    }\n\n    class ColorPoint extends Point {\n      constructor() {}\n    }\n\n    let cp = new ColorPoint(); // ReferenceError\n    ```\n\n  - 在子类的构造函数中，只有调用`super`之后，才可以使用`this`关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有`super`方法才能调用父类实例。\n\n    ```javascript\n    class Point {\n      constructor(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n    }\n\n    class ColorPoint extends Point {\n      constructor(x, y, color) {\n        this.color = color; // ReferenceError\n        super(x, y);\n        this.color = color; // 正确\n      }\n    }\n    ```\n\n- super\n\n  - `super`这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同\n\n    - 第一种情况，`super`作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次`super`函数。\n\n      ```js\n      class A {}\n\n      class B extends A {\n        constructor() {\n          super();\n        }\n      }\n      ```\n\n      解说：上面代码中，子类`B`的构造函数之中的`super()`，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。`super`虽然代表了父类`A`的构造函数，但是返回的是子类`B`的实例，即`super`内部的`this`指的是`B的实例，因此`super()`在这里相当于`A.prototype.constructor.call(this)`\n\n    - 第二种情况，`super`作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类\n\n      ```javascript\n      class A {\n        p() {\n          return 2;\n        }\n      }\n\n      class B extends A {\n        constructor() {\n          super();\n          console.log(super.p()); // 2\n        }\n      }\n\n      let b = new B();\n      ```\n\n    - 由于`super`指向父类的原型对象(prototype)，所以定义在父类实例上的方法或属性，是无法通过`super`调用的\n\n      ```javascript\n      class A {\n        constructor() {\n          this.p = 2;\n        }\n      }\n\n      class B extends A {\n        get m() {\n          return super.p;\n        }\n      }\n\n      let b = new B();\n      b.m; // undefined\n      ```\n\n# Set\n\n#### 基本用法\n\n- ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\n- `Set`本身是一个构造函数，用来生成 Set 数据结构。\n\n- `Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n\n  ```js\n  const set = new Set([1, 2, 3, 4, 4]);\n  console.log(set); //[1,2,3,4]\n  ```\n\n  - 数组去重\n\n    ```js\n    [...new Set([1, 2, 3, 2, 4, 5])]; //[1,2,3,4,5]\n    ```\n\n  - 字符串去重\n\n    ```js\n    [...new Set(\"ababbc\")].join(\"\"); //\"abc\"\n    ```\n\n#### 属性和方法\n\n- Set 结构的实例有以下属性。\n\n  - `Set.prototype.constructor`：构造函数，默认就是`Set`函数。\n  - `Set.prototype.size`：返回`Set`实例的成员总数。\n\n- Set 实例的方法分为两大类\n\n  - 操作方法（用于操作数据）\n\n    - `Set.prototype.add(value)`：添加某个值，返回 Set 结构本身\n\n      ```js\n      const items = new Set([]);\n      items.add(1).add(2).add(3);\n      console.dir(items); //[1,2,3]\n      ```\n\n    - `Set.prototype.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功\n\n      ```js\n      const items = new Set([12, 23, 34]);\n      var b = items.delete(12);\n      console.log(b); //true\n      console.log(items); //Set(2) {23, 34}\n      ```\n\n    - `Set.prototype.has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。\n\n    - `Set.prototype.clear()`：清除所有成员，没有返回值\n\n      ```js\n      const items = new Set([12, 23, 34]);\n      var b = items.clear(12);\n      console.log(b); //undefined\n      console.log(items); //Set(0) {}\n      ```\n\n  - 遍历方法（用于遍历成员）\n\n    - `Set.prototype.keys()`：返回键名的遍历器\n\n    - `Set.prototype.values()`：返回键值的遍历器\n\n    - Set.prototype.entries()\n\n      ```js\n      let set = new Set([\"red\", \"green\", \"blue\"]);\n      for (let item of set.keys()) {\n        console.log(item);\n      }\n      // red\n      // green\n      // blue\n      for (let item of set.values()) {\n        console.log(item);\n      }\n      // red\n      // green\n      // blue\n      for (let item of set.entries()) {\n        console.log(item);\n      }\n      // [\"red\", \"red\"]\n      // [\"green\", \"green\"]\n      // [\"blue\", \"blue\"]\n      ```\n\n    - Set.prototype.forEach()\n\n      ```js\n      let set = new Set([1, 4, 9]);\n      set.forEach((value, key) => console.log(key + \" : \" + value));\n      // 1 : 1\n      // 4 : 4\n      // 9 : 9\n      ```\n\n# Map\n\n#### 概述\n\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\n#### 基本用法\n\n- 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组\n\n  ```js\n  const map = new Map([\n    [\"name\", \"张三\"],\n    [\"title\", \"Author\"],\n  ]);\n\n  map.size; // 2\n  map.has(\"name\"); // true\n  map.get(\"name\"); // \"张三\"\n  map.has(\"title\"); // true\n  map.get(\"title\"); // \"Author\"\n  ```\n\n#### 属性和方法\n\n- size 属性，`size`属性返回 Map 结构的成员总数。\n\n  ```js\n  const map = new Map();\n  map.set(\"foo\", true);\n  map.set(\"bar\", false);\n\n  map.size; // 2\n  ```\n\n- Map.prototype.set(key, value) `set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键， set()方法返回的是 set 对象可以采用链式写法\n\n  ```js\n  const m = new Map();\n\n  m.set(\"edition\", 6); // 键是字符串\n  m.set(262, \"standard\"); // 键是数值\n  m.set(undefined, \"nah\"); // 键是 undefined\n  ```\n\n- Map.prototype.get(key) `get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。\n\n  ```js\n  const m = new Map();\n\n  const hello = function () {\n    console.log(\"hello\");\n  };\n  m.set(hello, \"Hello ES6!\"); // 键是函数\n\n  m.get(hello); // Hello ES6!\n  ```\n\n- Map.prototype.has(key)`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\n\n  ```js\n  const m = new Map();\n\n  m.set(\"edition\", 6);\n  m.set(262, \"standard\");\n  m.set(undefined, \"nah\");\n\n  m.has(\"edition\"); // true\n  m.has(\"years\"); // false\n  m.has(262); // true\n  m.has(undefined); // true\n  ```\n\n* Map.prototype.delete(key)`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。\n\n  ```js\n  const m = new Map();\n  m.set(undefined, \"nah\");\n  m.has(undefined); // true\n\n  m.delete(undefined);\n  m.has(undefined); // false\n  ```\n\n* Map.prototype.clear()`clear`方法清除所有成员，没有返回值\n\n  ```js\n  let map = new Map();\n  map.set(\"foo\", true);\n  map.set(\"bar\", false);\n\n  map.size; // 2\n  map.clear();\n  map.size; // 0\n  ```\n\n#### 遍历\n\n- `Map.prototype.keys()`：返回键名的遍历器。\n\n- `Map.prototype.values()`：返回键值的遍历器\n\n- `Map.prototype.entries()`：返回所有成员的遍历器\n\n- `Map.prototype.forEach()`：遍历 Map 的所有成员\n\n  ```js\n  const map = new Map([\n    [\"F\", \"no\"],\n    [\"T\", \"yes\"],\n  ]);\n\n  for (let key of map.keys()) {\n    console.log(key);\n  }\n  // \"F\"\n  // \"T\"\n\n  for (let value of map.values()) {\n    console.log(value);\n  }\n  // \"no\"\n  // \"yes\"\n\n  for (let item of map.entries()) {\n    console.log(item[0], item[1]);\n  }\n  // \"F\" \"no\"\n  // \"T\" \"yes\"\n\n  // 或者\n  for (let [key, value] of map.entries()) {\n    console.log(key, value);\n  }\n  // \"F\" \"no\"\n  // \"T\" \"yes\"\n  map.forEach(function (value, key, map) {\n    console.log(\"Key: %s, Value: %s\", key, value);\n  });\n  ```\n\n  `forEach`方法还可以接受第二个参数，用来绑定`this`。\n\n# Symbol\n\n#### 概述\n\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。ES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）Symbol 值通过`Symbol`函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\n```js\nvar obj = {\n  say: \"lagou\",\n};\nvar say = Symbol(); //say 是symbol类型\nobj[say] = \"web\";\nconsole.log(obj); //{say: \"lagou\", Symbol(): \"web\"}\n```\n\n#### 语法\n\n- `Symbol`函数前不能使用`new`命令，否则会报错\n\n- `Symbol`函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分\n\n- 每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性\n\n  ```js\n  var a = Symbol();\n  var b = Symbol();\n  console.log(a === b); //false\n  var a = Symbol(\"a\");\n  var b = Symbol(\"b\");\n  console.log(a === b); //false\n  ```\n\n  注意：`Symbol`函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的`Symbol`函数的返回值是不相等的\n\n  ```js\n  var a = Symbol(\"a\");\n  var b = Symbol(\"a\");\n  console.log(a === b); //false\n  ```\n\n- Symbol 值不能与其他类型的值进行运算，会报错\n\n  ```js\n  let sym = Symbol(\"My symbol\");\n\n  \"your symbol is \" +\n    sym // TypeError: can't convert symbol to string\n    `your symbol is ${sym}`;\n  // TypeError: can't convert symbol to string\n  ```\n\n- Symbol 值作为对象属性名时，不能用点运算符\n\n  ```js\n  const mySymbol = Symbol();\n  const a = {};\n  a.mySymbol = \"Hello!\";\n  console.log(a[mySymbol]); //undefined\n  console.log(a[\"mySymbol\"]); //hello\n  ```\n\n* Symbol 作为属性名，遍历对象的时候，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols()`方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\n\n  ```js\n  const obj = {};\n  let a = Symbol(\"a\");\n  let b = Symbol(\"b\");\n  obj[a] = \"Hello\";\n  obj[b] = \"World\";\n  const objectSymbols = Object.getOwnPropertySymbols(obj);\n  console.log(objectSymbols); //[Symbol(a), Symbol(b)]\n  ```\n\n* 有时，我们希望重新使用同一个 Symbol 值，`Symbol.for()`方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。\n\n  ```js\n  let s1 = Symbol.for(\"foo\");\n  let s2 = Symbol.for(\"foo\");\n\n  s1 === s2; // true\n  ```\n\n  `Symbol.for()`与`Symbol()`这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。`Symbol.for()`不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的`key`是否已经存在，如果不存在才会新建一个值。比如，如果你调用`Symbol.for(\"cat\")`30 次，每次都会返回同一个 Symbol 值，但是调用`Symbol(\"cat\")`30 次，会返回 30 个不同的 Symbol 值\n\n  ```js\n  Symbol.for(\"bar\") === Symbol.for(\"bar\");\n  // true\n\n  Symbol(\"bar\") === Symbol(\"bar\");\n  ```\n\n  由于`Symbol()`写法没有登记机制，所以每次调用都会返回一个不同的值。`Symbol.for()`为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行\n\n  ```js\n  function foo() {\n    return Symbol.for(\"bar\");\n  }\n\n  const x = foo();\n  const y = Symbol.for(\"bar\");\n  console.log(x === y); // true\n  ```\n\n# 可迭代接口\n\n#### Iterater 的概念\n\n- 简单介绍\n\n  JavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\n\n  遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n\n  Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。\n\n- Iterator 的遍历过程\n\n  - 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n\n  - 第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员\n\n  - 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员\n\n  - 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置\n\n    每一次调用`next`方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含`value`和`done`两个属性的对象。其中，`value`属性是当前成员的值，`done`属性是一个布尔值，表示遍历是否结束。\n\n    ```js\n    简单的Iterator遍历器的实现;\n    var it = easyIterator([\"a\", \"b\"]);\n\n    it.next(); // { value: \"a\", done: false }\n    it.next(); // { value: \"b\", done: false }\n    it.next(); // { value: undefined, done: true }\n\n    function easyIterator(array) {\n      var nextIndex = 0;\n      return {\n        next: function () {\n          return nextIndex < array.length\n            ? { value: array[nextIndex++], done: false }\n            : { value: undefined, done: true };\n        },\n      };\n    }\n    ```\n\n#### Iterater 接口\n\n- 字符串 数组 set map arguments 都有 iterater 接口，nodelist 集合，都可以用 for of 遍历\n\n  ```js\n  var st = \"lagou\";\n  for (i of st) {\n    console.log(i); // l a g o u\n  }\n  var arr = [1, 2];\n  for (v of arr) {\n    console.log(v); //1 2\n  }\n  function fn(a, b, c) {\n    for (i of arguments) {\n      console.log(i); //1 2 3\n    }\n  }\n  fn(1, 2, 3);\n  ```\n\n# Modules\n\n#### 概述\n\n- JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\n\n#### 语法\n\n- export\n\n  - `export`命令用于规定模块的对外接口\n\n  - 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量。下面是一个 JS 文件，里面使用`export`命令输出变量\n\n    ```javascript\n    //demo.js\n    export var firstName = \"Michael\";\n    export var lastName = \"Jackson\";\n    export var year = 1958;\n    //或者\n    var firstName = \"Michael\";\n    var lastName = \"Jackson\";\n    var year = 1958;\n\n    export { firstName, lastName, year };\n    ```\n\n- import\n\n  - `import`命令用于输入其他模块提供的功能\n\n  - `import`命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（`profile.js`）对外接口的名称相同\n\n    ```javascript\n    // main.js\n    import { firstName, lastName, year } from \"./profile.js\";\n\n    function setName(element) {\n      element.textContent = firstName + \" \" + lastName;\n    }\n    ```\n\n  -\n\n- export default\n\n  - 为了给用户提供方便，就要用到`export default`命令，为模块指定默认输出\n\n  - 本质上，`export default`就是输出一个叫做`default`的变量或方法，然后系统允许你为它取任意名字\n\n  - 在`import`命令后面，不再使用大括号\n\n  - `export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此`export default`命令只能使用一次\n\n    ```javascript\n    // export-default.js\n    export default function () {\n      console.log(\"foo\");\n    }\n    ```\n\n    ```javascript\n    // import-default.js\n    import customName from \"./export-default\";\n    customName(); // 'foo'\n    ```\n\n#### 浏览器端加载实现\n\n- 浏览器加载 ES6 模块，也使用标签，但是要加入`type=\"module\"`属性\n\n  ```js\n  // 01.js\n  export var a = 123;\n  ```\n\n  ```js\n  //demo.html\n  <script type=\"module\">import {a} from \"./01.js\"; console.log(a)//123</script>\n  ```\n\n* 脚本异步加载\n\n  ```html\n  <script src=\"path/to/myModule.js\" defer></script>\n  <script src=\"path/to/myModule.js\" async></script>\n  ```\n\n  解说：上面代码中，标签打开`defer`或`async`属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。defer 与 async 的区别是：defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。\n","source":"_posts/es6整理.md","raw":"---\ntitle: es6整理\ndate: 2020-9-14 09:47:13\ntags:\n    - js\ncategories:\n    - 笔记\n##tranquilpeak添加的属性\ndisqusIdentifier: fdsF34ff34\nkeywords:\n- javascript\nclearReading: true\nthumbnailImage: https://res.cloudinary.com/ddb5vwne6/image/upload/v1597758372/timg_fy8o3h.jpg\nthumbnailImagePosition: bottom\nautoThumbnailImage: yes\nmetaAlignment: center\ncoverImage: cover-v1.2.0.jpg\ncoverCaption: \"A beautiful sunrise\"\ncoverMeta: out\ncoverSize: partial\ncomments: false\nmeta: false\nactions: false\n---\nECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。\n\n<!--excerpt-->\n**ECMAScript2015**\n\n# 摘要\n\n#### 1.新的标准规范\n\nECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。\n\n#### 2.ECMAScript 和 js 关系\n\nECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。javascript 是 netscape 创 造的并交给了国际标准化组织 ECMA，之所以不叫做 JavaScript 由于商标的问题，java 是 sun 公司的商标，根据 授权协议只有 Netscape 公司可以合法使用 JavaScript 这个名字，另外就是为了体现 JavaScript 的标准的制定者 不是 ECMA 所以取名为 ECMAScript。\n\n#### 3.ES6 与 ECMAScript 2015 的关系\n\nES6 是 ECMA 的为 JavaScript 制定的第 6 个版本的标准，标准委员会最终决定，标准在每年的 6 月份正式发布一 次，作为当年的正式版本。ECMAscript 2015 是在 2015 年 6 月份发布的 ES6 的第一个版本。依次类推 ECMAscript 2016 是 ES6 的第二个版本、 ECMAscript 2017 是 ES6 的第三个版本……\n\n# 块级作用域\n\n#### 1.块级作用域的种类\n\nECMAScript2015 为 js 提出的第三个作用域，凡是带{}的都是一个块级作用域。\n\nif 语句的{},for 循环中的{},while 中的{},或者是我们单独写的{} try{}catch(error){}这些都提供了块级作用域。\n\n#### 块级作用域分析\n\n##### 1.为什么需要块级作用域？\n\n- 内层变量会覆盖外层变量\n\n  ```js\n  var lagou = \"拉勾\";\n  function fn() {\n    console.log(lagou); //undefined\n    if (false) {\n      var lagou = \"hello\";\n    }\n  }\n  fn();\n  ```\n\n这是因为 fn 函数体内以及有 var 声明的变量 lagou，只是还没有赋值，默认为 undefined。\n\n- 用来计数的循环变量泄露为全局变量\n\n  ```js\n  for (var i = 0; i < 10; i++) {}\n  // 10\n  console.log(i);\n  ```\n\n##### 2.块级作用域的成员\n\n块级作用域内的成员需要使用 let 或 const 命令定义的变量。\n\n```js\nvar lagou = \"拉勾\";\nfunction fn() {\n  console.log(lagou); //拉勾\n  if (true) {\n    let lagou = \"hello\";\n  }\n}\nfn();\n```\n\n# let const\n\n#### 1.let\n\n基本用法\n\nECMAScript2015 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效。\n\nlet 主要声明块级作用域下的成员，这个成员变量的作用域范围只能在当前块级作用域下。\n\n- wer\n- er\n\n#### 2.const\n\nconst 声明变量的同时必须要赋值。\n\nconst 声明之后，不允许去修改它的值，这里面的值说的是不允许修改它，是声明之后不允许重新指向一个新\n\n的内存地址，可以去修改内存地址中的属性成员。\n\n# 数组\n\n#### 1.数组的解构\n\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。\n\n- 完全解构 将数组中的每一个值都对应上相应的变量。\n\n  ```js\n  var arr = [\"lagou\", \"edu\", \"web\"];\n  let [com, ind, work] = arr;\n  console.log(work); //web\n  ```\n\n- 不完全解构 数组中的部分值对应上了相应的变量。\n\n  ```js\n  var arr = [\"lagou\", \"edu\", \"web\"];\n  let [, , work] = arr;\n  console.log(work); //web\n  ```\n\n  注意:模式没有匹配上的可以不填，但是必须要加逗号隔开。\n\n* 扩展运算符...\n\n  - 展开运算符说明\n\n    - 三个点(…)是一个展开运算符，其功能为对三个点后面的变量进行展开操作\n\n    - 三个点(…)展开运算符:只能对具有 Iterator 接口的对象进行展开操作\n\n    - 使用场景\n\n          ![image-20200508180111209](imgs/image-20200508180111209.png)\n\n          案例一\n\n          ```js\n\n      var arr=[\"拉勾\",\"edu\",\"web\"];\n      fn(...arr)//web\n      `案例二`js\n      let a = [88,99,100];\n      let b = [101,102,103];\n      a.push(...b);\n      console.log(a);//[88, 99, 100, 101, 102, 103]\n      `案例三`js\n      let d={\n      e:\"拉钩教育\",\n      f:\"www.lagou.com\"\n      }\n      let obj={\n      g:\"web\",\n      h:1100,\n      ...d\n      };\n      console.log(obj);\n      {g: \"web\", h: 1100, e: \"拉钩教育\", f: \"www.lagou.com\"}\n      `案例四`js\n      var st=\"拉钩 edu\";\n      var arr=[...st];\n      console.log(arr)//[\"拉\", \"钩\", \"e\", \"d\", \"u\"]\n      `掌握了展开运算符的使用规则，我们看一下数组的特殊解构。`js\n      let [a,...b] = [1,2,3,4,5,6];\n      console.log(a)//1\n      console.log(b)//[2,3,4,5,6]\n\n      ```\n\n      ```\n\n* 解构不成功\n\n  右边的变量的个数超过了等号左边中数组的元素\n\n  ```js\n  let [a, b, c] = [12];\n  console.log(b); //undefined\n  ```\n\n  如果解构没有成功，则变量的值是 undefined，如果是展开运算的变量则是空数组。\n\n  ```javascript\n  let [a, b, ...c] = [12];\n  console.log(c); //[]\n  ```\n\n#### 2.数组的扩展\n\n- 扩展运算符...\n\n  - 扩展运算符（spread）是三个点（`...`）它好比<a href=\"#rest\"> rest 参数的逆运算</a>，将一个数组转为用逗号分隔的参数序列。\n\n  - 替代 apply()的使用技巧\n\n    我们之前在求一个数组中的最大值得时候采用得方式是 Math.max.apply(null,[12,34,56,43]) ==56\n\n    ```js\n    var max = Math.max.apply(null, [12, 34, 56, 43]);\n    console.log(max); //56\n    var max2 = Math.max(...[12, 34, 56, 43]);\n    console.log(max2); //56\n    ```\n\n- Array 类的扩展方法\n\n  - Array.from()\n\n  Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）\n\n  ```js\n  var arraylike = {\n    0: \"lagou\",\n    1: \"edu\",\n    2: \"web\",\n    length: 3,\n  };\n  var arr = Array.from(arraylike);\n  [\"lagou\", \"edu\", \"web\"];\n  ```\n\n  Array.from 还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组\n\n  ```js\n  var arr = Array.from([1, 2, 3], function (x) {\n    return x * x;\n  });\n  console.log(arr); //[1,4,9]\n  ```\n\n  - Array.of 方法用于将一组值，转换为数组，这个方法的主要目的，是弥补数组构造函数`Array()`的不足。因为参数个数的不同，会导致`Array()`的行为有差异。\n\n    ```js\n    var arr = Array(3); //[emptyx3]\n    ```\n\n    这里面 3 表示数组中元素的长度。\n\n    ```js\n    var arr = Array(2, 3, 4); //[2,3,4]\n    ```\n\n    当`Array()`里的参数个数大于 1 的时候，表示的是数组元素。\n\n    `Array.of()`方法不管里面参数的个数多少，都将其转为数组的元素。\n\n    ```js\n    var arr = Array.of(3);\n    console.log(arr); //[3]\n    ```\n\n# 对象\n\n#### 1.对象中有关变量的解构赋值\n\n解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\n```js\nlet { name, work } = { name: \"lagou\", work: \"web\" };\nconsole.log(name, work); //lagou web\n```\n\n#### 2.对象的扩展\n\n- 对象的简写\n\n  - 当变量名和属性名同名式，省略同名的属性值\n\n    ```js\n    const foo = \"bar\";\n    const baz = { foo };\n    // 等同于\n    const baz = { foo: foo };\n    ```\n\n- 省略方法中的 function\n\n  ```js\n  const obj = {\n    method() {\n      return \"拉勾!\";\n    },\n  };\n  // 等同于\n  const obj = {\n    method: function () {\n      return \"拉勾!\";\n    },\n  };\n  ```\n\n  - 属性的赋值器（setter）和取值器（getter）\n\n    ```js\n    const lagou = {\n      name: \"拉勾\",\n      get com() {\n        return this.name;\n      },\n      set work(value) {\n        this.name = this.name + value;\n      },\n    };\n    console.log(lagou.com); //拉勾\n    lagou.work = \"招聘\";\n    console.log(lagou.name); //拉勾招聘\n    ```\n\n  - 属性名表达式\n\n    es5 中定义对象的属性有两种方法，一种是用标识符做属性，一种是用表达式做属性\n\n    ```js\n    方法一;\n    obj.name = \"拉勾\";\n    // 方法二\n    obj[\"name\"] = \"拉勾\";\n\n    var lagou = {\n      name: \"拉勾\",\n    };\n    ```\n\n    如果使用大括号定义对象，那么在 es5 中只能使用标识符定义属性。\n\n    ```js\n    var lagou = {\n      name: \"拉勾\",\n    };\n    ```\n\n    但是 ECMAScript2015 在使用大括号定义对象的时候，允许使用表达式定义属性，把表达式放在方括号中。\n\n    ```js\n    let name = \"lagou\";\n    const lagou = {\n      [name]: \"web\",\n    };\n    console.log(lagou); //{lagou: \"web\"}\n    ```\n\n#### 3.三点运算在对象中的用途\n\n- 用于对象的解构\n\n  - 对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。\n\n    ```js\n    let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\n    console.log(z); //{a: 3, b: 4}\n    ```\n\n    上面代码中，变量`z`是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（`a`和`b`），将它们连同值一起拷贝过来。\n\n        注意:1.解构赋值必须是最后一个参数。2.解构赋值的拷贝是浅拷贝。\n\n- 用于扩展运算\n\n  - 对象的扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。\n\n    ```js\n    let z = { name: \"lagou\", work: \"web\" };\n    let n = { ...z };\n    n; // { name: \"lagou\", work: \"web\" }\n    ```\n\n# 字符串\n\n#### 1.字符串模板\n\n- 传统的字符串里不能使用换行符，必须使用转义符\\n 替代，字符串模板里可以使用。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\n\n- 模板字符串中嵌入变量，需要将变量名写在`${}`之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性\n\n  ```js\n  var name = \"拉勾\";\n  var st = `欢迎来到${name}`;\n  console.log(st);\n  ```\n\n#### 2.标签模板\n\n- 模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能。\n\n  ```js\n  console.log`hello`;\n  等同于;\n  console.log([\"hello\"]);\n  ```\n\n  标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。\n\n  注意:如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。\n\n  ```js\n  var name=\"laogou\";\n  var work=\"web\"\n  function tag(st,a,b){\n      console.log(st);\n      console.log(a);\n      console.log(b)\n      return \"hello lagou\";\n  }\n  var st=tag`hello${name},职业${work}开发`\n  console.log(st)//hello lagou\n  [\"hello\", \",职业\", \"开发\", raw: Array(3)]\n  laogou\n  web\n  ```\n\n  函数内的返回值，就是`tag`函数处理模板字符串后的返回值。\n\n  ```js\n  var name = \"laogou\";\n  var work = \"web\";\n  function tag(st, a, b) {\n    console.log(st);\n    console.log(a);\n    console.log(b);\n    return \"hello lagou\"; //如果没有返回值，则默认是undefined\n  }\n  var st = tag`hello${name},职业${work}开发`;\n  console.log(st); //hello lagou\n  ```\n\n#### 3.扩展的方法\n\n- 字符串实例的方法\n\n  - **includes()**\n\n    返回布尔值，表示是否找到了参数字符串\n\n    ```javascript\n    var st = \"lagou web\";\n    var b = st.includes(\"web\");\n    console.log(b); //true\n    ```\n\n  - **startsWith()**\n\n    返回布尔值，表示参数字符串是否在原字符串的头部\n\n    ```javascript\n    var st = \"lagou web\";\n    var b = st.startsWith(\"la\");\n    console.log(b); //true\n    ```\n\n  - **endsWith()**\n\n    返回布尔值，表示参数字符串是否在原字符串的尾部\n\n    ```javascript\n    var st = \"lagou web\";\n    var b = st.endsWith(\"web\");\n    console.log(b); //true\n    ```\n\n# 函数\n\n#### 参数默认值\n\n- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\n  ```javascript\n  function fn(a, b = \" lagou \") {\n    console.log(a + b);\n  }\n  fn(\"hello\"); //hello lagou\n  ```\n\n- 注意:\n\n  - 参数变量是默认声明的，所以不能用`let`或`const`再次声明.\n  - 使用参数默认值时，函数不能有同名参数\n\n- 参数默认值的位置\n\n  - 通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。\n\n    ```javascript\n    function f(x = 1, y) {\n      return [x, y];\n    }\n\n    f() // [1, undefined]\n    f(2) // [2, undefined]\n    f(, 1) // 报错\n    ```\n\n#### <span name=\"app\">rest 参数</span>\n\n- ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\n  ```javascript\n  function add(...values) {\n    console.log(values);\n  }\n  add(2, 5, 3); // [2, 5, 3]\n  ```\n\n- rest 参数和函数中的参数解构有什么区别\n\n  - rest 参数是发生在函数的定义阶段，函数的额参数解构是发生在函数的调用阶段\n  - 二者是一种互为逆运算\n\n```javascript\nfunction add(...values) {\n  //这是rest参数\n  console.log(values);\n}\nadd(2, 5, 3); // [2, 5, 3]\nvar arr = [1, 2, 3];\nfunction fn(a, b, c) {\n  console.log(a + b + c);\n}\nfn(...arr); //6  这是参数的解构\n```\n\n#### 箭头函数\n\n- ES6 允许使用“箭头”（`=>`）定义函数。\n\n```javascript\nvar f = (v) => v;\n// 等同于\nvar f = function (v) {\n  return v;\n};\n```\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\n\n```javascript\nvar f = () => 5;\n// 等同于\nvar f = function () {\n  return 5;\n};\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function (num1, num2) {\n  return num1 + num2;\n};\n```\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用`return`语句返回。\n\n```javascript\nvar sum = (num1, num2) => {\n  return num1 + num2;\n};\n```\n\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\n\n```javascript\nlet getItem = id => { id: id, name: \"Temp\" }; //报错\n\nlet getItem = id => ({ id: id, name: \"Temp\" });//不报错\n```\n\n- 箭头函数有几个使用注意点\n  - 函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数外面的 this 是什么，箭头函数内的 this 还是什么。\n  - 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n  - 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n\n```javascript\nvar name=\"web\"\nvar obj={\n    name:\"lagou\",\n    fn(){\n        var t=setTimeout(function(){\n            console.log(this.name)//web  this是window\n        },1000)\n    }\n}\nobj.fn()\n-----------------------------------\nvar name=\"web\"\nvar obj={\n    name:\"lagou\",\n    fn(){\n        var t=setTimeout(()=>{\n            console.log(this.name)//lagou this是obj\n        },1000)\n    }\n}\nobj.fn()\n```\n\n# Object\n\n#### Object.assign()\n\n- `Object.assign`方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。\n\n  ```javascript\n  const target = {\n    a: 123,\n    b: 123,\n  };\n  const sourcel = {\n    a: 456,\n    c: 456,\n  };\n  const result = Object.assign(target, sourcel);\n  console.log(target); //{a: 456, b: 123, c: 456}\n  console.log(target === result); //true\n  ```\n\n  如果目标对象与源对象有同名属性，则后面的属性会覆盖前面的属性。且`assign()`的返回值就是第一个对象。\n\n  如果有多个源对象有同名属性，依然是后面的会覆盖前面的属性\n\n  ```javascript\n  const target = { a: 1, b: 1 };\n  const source1 = { b: 2, c: 2 };\n  const source2 = { c: 3 };\n  Object.assign(target, source1, source2);\n  target; // {a:1, b:2, c:3}\n  ```\n\n- 利用`Object.assign()`复制一个对象，且其中一个对象的修改不会影响到另一个对象\n\n  ```javascript\n  const sourcel = {\n    a: 123,\n  };\n  var obj = Object.assign({}, sourcel);\n  obj.a = 456;\n  console.log(obj); //{a: 456}\n  console.log(sourcel); //{a: 123}\n  ```\n\n#### Object.is()\n\n- `Object.is`就是用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\n\n  ES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\n\n  ```js\n  console.log(Object.is(+0, -0)); //false\n  console.log(+0 === -0); //true\n  console.log(Object.is(NaN, NaN)); //true\n  console.log(NaN === NaN); //false\n  ```\n\n# Proxy\n\n#### 概述\n\nProxy 可以理解成一个快递员，我们发快递还是接受快递，都需要这个快递员充当一个代理的作用。ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例，这个实例就是一个代理对象（快递员）。\n\n```js\nvar proxy = new Proxy(target, handler);\n```\n\n#### 目标对象\n\n这个代理对象有两个参数，一个是代理的目标对象，第二个也是一个对象，它是配置对象，用来定制代理的拦截行为。\n\n```js\nconst person = {\n  name: \"zce\",\n  age: 20,\n};\nconst personProxy = new Proxy(person, {\n  get(target, property) {\n    console.log(target, property); //person{name:\"zce\",age:20}\n    return 100;\n  },\n  set() {},\n});\n```\n\n#### 配置对象\n\n- 配置对象中一般有两个方法`get`和`set`,`get`是用来拦截对目标对象属性的访问请求。`get`方法中有两个参数，第一个参数是目标对象，第二个参数是访问的那个属性。\n\n  ```js\n  const person = {\n    name: \"zce\",\n    age: 20,\n  };\n  const personProxy = new Proxy(person, {\n    get(target, property) {\n      console.log(target, property);\n      return 100;\n    },\n    set() {},\n  });\n\n  console.log(personProxy.name); //100\n  ```\n\n注意，这个`get`方法的返回值就是我们获取的这个属性的返回值。\n\n- 这个`get`方法中有三个参数，一个是代理的目标对象，一个是代理的处理对象，第三个参数是 proxy 实例本身，且第三个参数是可选参数。\n\n  ```js\n  const person = {\n    name: \"zce\",\n    age: 20,\n  };\n  const personProxy = new Proxy(person, {\n    get(target, property, o) {\n      console.log(o); //proxy{name:\"zec\",age:20}\n      return property in target ? target[property] : undefined;\n    },\n    set() {},\n  });\n\n  console.log(personProxy.age); //20\n  ```\n\n- 这个`set`方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选\n\n  ```js\n  const person = {\n    name: \"zce\",\n    age: 20,\n  };\n  const personProxy = new Proxy(person, {\n    get(target, property, o) {\n      return property in target ? target[property] : undefined;\n    },\n    set(obj, pro, value, o) {\n      console.log(obj, pro, value, o);\n    },\n  });\n\n  console.log((personProxy.name = \"zhang\"));\n  //{name: \"zce\", age: 20} \"name\" \"zhang\" Proxy {name: \"zce\", age: 20}\n  ```\n\n  可以去设置一些属性或修改\n\n  ```js\n  const person = {\n    name: \"zce\",\n    age: 20,\n  };\n  const personProxy = new Proxy(person, {\n    get(target, property, o) {\n      return property in target ? target[property] : undefined;\n    },\n    set(target, pro, value, o) {\n      //可以做一些内部校验\n      target[pro] = value;\n    },\n  });\n  console.log((personProxy.name = \"lagou\"));\n  person; //{name:\"lagou\",age:20}\n  ```\n\n# Reflect\n\n#### 概述\n\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\n\n- 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法\n\n- 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`\n\n  ```js\n  // 老写法\n  try {\n    Object.defineProperty(target, property, attributes);\n    // success\n  } catch (e) {\n    // failure\n  }\n\n  // 新写法\n  if (Reflect.defineProperty(target, property, attributes)) {\n    // success\n  } else {\n    // failure\n  }\n  ```\n\n- 让`Object`操作都变成函数行为。某些`Object`操作是命令式，比如`name in obj`和`delete obj[name]`，而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了函数行为。\n\n  ```js\n  // 老写法\n  \"assign\" in Object; // true\n\n  // 新写法\n  Reflect.has(Object, \"assign\"); // true\n  ```\n\n#### 静态方法\n\n- Reflect.get\n\n  - `Reflect.get(target, name, receiver)`,`Reflect.get`方法查找并返回`target`对象的`name`属性，如果没有该属性，则返回`undefined`\n\n    ```js\n    var myObject = {\n      foo: 1,\n      bar: 2,\n      get baz() {\n        return this.foo + this.bar;\n      },\n    };\n\n    Reflect.get(myObject, \"foo\"); // 1\n    Reflect.get(myObject, \"bar\"); // 2\n    Reflect.get(myObject, \"baz\"); // 3\n    ```\n\n  - 如果`name`属性部署了读取函数（getter），则读取函数的`this`绑定`receiver`。\n\n    ```js\n    var myObject = {\n      foo: 1,\n      bar: 2,\n      get baz() {\n        return this.foo + this.bar;\n      },\n    };\n\n    var myReceiverObject = {\n      foo: 4,\n      bar: 4,\n    };\n\n    Reflect.get(myObject, \"baz\", myReceiverObject); // 8\n    ```\n\n  - 如果第一个参数不是对象，`Reflect.get`方法会报错。\n\n    ```js\n    Reflect.get(1, \"foo\"); // 报错\n    Reflect.get(false, \"foo\"); // 报错\n    ```\n\n- Reflect.set\n\n  - `Reflect.set(target, name, value, receiver)`,`Reflect.set`方法设置`target`对象的`name`属性等于`value`\n\n    ```js\n    var myObject = {\n      foo: 1,\n    };\n\n    myObject.foo; // 1\n\n    Reflect.set(myObject, \"foo\", 2);\n    myObject.foo; // 2\n    ```\n\n  - 如果`name`属性设置了赋值函数，则赋值函数的`this`绑定`receiver`。\n\n    ```js\n    var myObject = {\n      foo: 4,\n      set bar(value) {\n        return (this.foo = value);\n      },\n    };\n\n    var myReceiverObject = {\n      foo: 0,\n    };\n\n    Reflect.set(myObject, \"bar\", 1, myReceiverObject);\n    myObject.foo; // 4\n    myReceiverObject.foo; // 1\n    ```\n\n- Reflect.has\n\n  - `Reflect.has(obj, name)`,`Reflect.has`方法对应`name in obj`里面的`in`运算符\n\n    ```js\n    var myObject = {\n      foo: 1,\n    };\n\n    // 旧写法\n    \"foo\" in myObject; // true\n\n    // 新写法\n    Reflect.has(myObject, \"foo\"); // true\n    ```\n\n    如果`Reflect.has()`方法的第一个参数不是对象，会报错。\n\n- Reflect.deleteProperty\n\n  - Reflect.deleteProperty(obj, name),`Reflect.deleteProperty`方法等同于`delete obj[name]`，用于删除对象的属性\n\n    ```js\n    const myObj = { foo: \"bar\" };\n\n    // 旧写法\n    delete myObj.foo;\n\n    // 新写法\n    Reflect.deleteProperty(myObj, \"foo\");\n    ```\n\n    该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回`true`；删除失败，被删除的属性依然存在，返回`false`。如果`Reflect.deleteProperty()`方法的第一个参数不是对象，会报错.\n\n# Promise\n\n#### 概述\n\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\n\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n#### promise 特点\n\n`Promise`对象有以下两个特点。\n\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。\n\n#### promise 使用方法\n\n- ES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。\n\n- `Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n  ```js\n  var p = new Promise(function (resolve, reject) {\n    if (true) {\n      resolve(data);\n    } else {\n      reject(data);\n    }\n  });\n  ```\n\n  `resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；`reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n- `Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。\n\n  ```js\n  p.then(\n    function (value) {\n      // success业务处理\n    },\n    function (error) {\n      // failure\n    }\n  );\n  ```\n\n  `then`方法可以接受两个回调函数作为参数。第一个回调函数是`Promise`对象的状态变为`resolved`时调用，第二个回调函数是`Promise`对象的状态变为`rejected`时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受`Promise`对象传出的值作为参数。\n\n  - 看一个简单的例子\n\n    ```js\n    function time(ms) {\n      return new Promise((resolve, reject) => {\n        setTimeout(resolve, ms);\n      });\n    }\n    time(1000).then((value) => {\n      console.log(value);\n    });\n    ```\n\n* Promise 新建后就会立即执行。\n\n  ```js\n  let promise = new Promise(function (resolve, reject) {\n    console.log(\"Promise\");\n    resolve();\n  });\n\n  promise.then(function () {\n    console.log(\"resolved.\");\n  });\n\n  console.log(\"Hi!\");\n  //Promise\n  //Hi\n  //resolved\n  ```\n\n# class\n\n#### 概述\n\nES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过`class`关键字，可以定义类。基本上，ES6 的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的`class`改写，就是下面这样。\n\n```js\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return \"(\" + this.x + \", \" + this.y + \")\";\n  }\n}\n```\n\n#### 基本介绍\n\n- `constructor()`\n\n  - `constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。\n\n- 类的实例\n\n  - 生成类的实例的写法，与 ES5 完全一样，也是使用`new`命令。前面说过，如果忘记加上`new`，像函数那样调用`Class`，将会报错。\n\n    ```js\n    class Point {\n      // ...\n    }\n    // 报错\n    var point = Point(2, 3);\n    // 正确\n    var point = new Point(2, 3);\n    ```\n\n  - 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。\n\n    ```js\n    class Point {\n      constructor(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n\n      toString() {\n        return \"(\" + this.x + \", \" + this.y + \")\";\n      }\n    }\n\n    var point = new Point(2, 3);\n\n    point.toString(); // (2, 3)\n\n    point.hasOwnProperty(\"x\"); // true\n    point.hasOwnProperty(\"y\"); // true\n    point.hasOwnProperty(\"toString\"); // false\n    point.__proto__.hasOwnProperty(\"toString\"); // true\n    ```\n\n  - 与 ES5 一样，类的所有实例共享一个原型对象\n\n    ```js\n    var p1 = new Point(2, 3);\n    var p2 = new Point(3, 2);\n\n    p1.__proto__ === p2.__proto__;\n    //true\n    ```\n\n* getter 和 setter\n\n  - 与 ES5 一样，在“类”的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\n    ```js\n    class MyClass {\n      constructor() {\n        // ...\n      }\n      get prop() {\n        return \"getter\";\n      }\n      set prop(value) {\n        console.log(\"setter: \" + value);\n      }\n    }\n\n    let inst = new MyClass();\n\n    inst.prop = 123;\n    // setter: 123\n\n    inst.prop;\n    // 'getter'\n    ```\n\n* 属性表达式\n\n  - 类的属性名，可以采用表达式\n\n    ```js\n    let methodName = \"getArea\";\n\n    class Square {\n      constructor(length) {\n        // ...\n      }\n\n      [methodName]() {\n        // ...\n      }\n    }\n    ```\n\n    上面代码中，`Square`类的方法名`getArea`，是从表达式得到的\n\n#### static\n\n- 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”\n\n  ```js\n  class Foo {\n    static classMethod() {\n      return \"hello\";\n    }\n  }\n\n  Foo.classMethod(); // 'hello'\n\n  var foo = new Foo();\n  foo.classMethod();\n  // TypeError: foo.classMethod is not a function\n  ```\n\n  解说：上面代码中，`Foo`类的`classMethod`方法前有`static`关键字，表明该方法是一个静态方法，可以直接在`Foo`类上调用（`Foo.classMethod()`），而不是在`Foo`类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。\n\n- 注意，如果静态方法包含`this`关键字，这个`this`指的是类，而不是实例\n\n  ```js\n  class Foo {\n    static bar() {\n      this.baz();\n    }\n    static baz() {\n      console.log(\"hello\");\n    }\n    baz() {\n      console.log(\"world\");\n    }\n  }\n\n  Foo.bar(); // hello\n  ```\n\n  解说：上面代码中，静态方法`bar`调用了`this.baz`，这里的`this`指的是`Foo`类，而不是`Foo`的实例，等同于调用`Foo.baz`。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。\n\n- 父类的静态方法，可以被子类继承\n\n  ```js\n  class Foo {\n    static classMethod() {\n      return \"hello\";\n    }\n  }\n\n  class Bar extends Foo {}\n\n  Bar.classMethod(); // 'hello'\n  ```\n\n- 静态属性\n\n  静态属性指的是 Class 本身的属性，即`Class.propName`，而不是定义在实例对象（`this`）上的属性\n\n  ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个[提案](https://github.com/tc39/proposal-class-fields)提供了类的静态属性，写法是在实例属性的前面，加上`static`关键字。\n\n  ```js\n  class MyClass {\n    static myStaticProp = 42;\n\n    constructor() {\n      console.log(MyClass.myStaticProp); // 42\n    }\n  }\n  ```\n\n#### 继承\n\n- 简介\n\n  - Class 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\n\n    ```js\n    class Point {}\n\n    class ColorPoint extends Point {}\n    ```\n\n    解说：上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类\n\n  - 子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。这是因为子类自己的`this`对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用`super`方法，子类就得不到`this`对象。\n\n    ```javascript\n    class Point {\n      /* ... */\n    }\n\n    class ColorPoint extends Point {\n      constructor() {}\n    }\n\n    let cp = new ColorPoint(); // ReferenceError\n    ```\n\n  - 在子类的构造函数中，只有调用`super`之后，才可以使用`this`关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有`super`方法才能调用父类实例。\n\n    ```javascript\n    class Point {\n      constructor(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n    }\n\n    class ColorPoint extends Point {\n      constructor(x, y, color) {\n        this.color = color; // ReferenceError\n        super(x, y);\n        this.color = color; // 正确\n      }\n    }\n    ```\n\n- super\n\n  - `super`这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同\n\n    - 第一种情况，`super`作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次`super`函数。\n\n      ```js\n      class A {}\n\n      class B extends A {\n        constructor() {\n          super();\n        }\n      }\n      ```\n\n      解说：上面代码中，子类`B`的构造函数之中的`super()`，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。`super`虽然代表了父类`A`的构造函数，但是返回的是子类`B`的实例，即`super`内部的`this`指的是`B的实例，因此`super()`在这里相当于`A.prototype.constructor.call(this)`\n\n    - 第二种情况，`super`作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类\n\n      ```javascript\n      class A {\n        p() {\n          return 2;\n        }\n      }\n\n      class B extends A {\n        constructor() {\n          super();\n          console.log(super.p()); // 2\n        }\n      }\n\n      let b = new B();\n      ```\n\n    - 由于`super`指向父类的原型对象(prototype)，所以定义在父类实例上的方法或属性，是无法通过`super`调用的\n\n      ```javascript\n      class A {\n        constructor() {\n          this.p = 2;\n        }\n      }\n\n      class B extends A {\n        get m() {\n          return super.p;\n        }\n      }\n\n      let b = new B();\n      b.m; // undefined\n      ```\n\n# Set\n\n#### 基本用法\n\n- ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\n\n- `Set`本身是一个构造函数，用来生成 Set 数据结构。\n\n- `Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。\n\n  ```js\n  const set = new Set([1, 2, 3, 4, 4]);\n  console.log(set); //[1,2,3,4]\n  ```\n\n  - 数组去重\n\n    ```js\n    [...new Set([1, 2, 3, 2, 4, 5])]; //[1,2,3,4,5]\n    ```\n\n  - 字符串去重\n\n    ```js\n    [...new Set(\"ababbc\")].join(\"\"); //\"abc\"\n    ```\n\n#### 属性和方法\n\n- Set 结构的实例有以下属性。\n\n  - `Set.prototype.constructor`：构造函数，默认就是`Set`函数。\n  - `Set.prototype.size`：返回`Set`实例的成员总数。\n\n- Set 实例的方法分为两大类\n\n  - 操作方法（用于操作数据）\n\n    - `Set.prototype.add(value)`：添加某个值，返回 Set 结构本身\n\n      ```js\n      const items = new Set([]);\n      items.add(1).add(2).add(3);\n      console.dir(items); //[1,2,3]\n      ```\n\n    - `Set.prototype.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功\n\n      ```js\n      const items = new Set([12, 23, 34]);\n      var b = items.delete(12);\n      console.log(b); //true\n      console.log(items); //Set(2) {23, 34}\n      ```\n\n    - `Set.prototype.has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。\n\n    - `Set.prototype.clear()`：清除所有成员，没有返回值\n\n      ```js\n      const items = new Set([12, 23, 34]);\n      var b = items.clear(12);\n      console.log(b); //undefined\n      console.log(items); //Set(0) {}\n      ```\n\n  - 遍历方法（用于遍历成员）\n\n    - `Set.prototype.keys()`：返回键名的遍历器\n\n    - `Set.prototype.values()`：返回键值的遍历器\n\n    - Set.prototype.entries()\n\n      ```js\n      let set = new Set([\"red\", \"green\", \"blue\"]);\n      for (let item of set.keys()) {\n        console.log(item);\n      }\n      // red\n      // green\n      // blue\n      for (let item of set.values()) {\n        console.log(item);\n      }\n      // red\n      // green\n      // blue\n      for (let item of set.entries()) {\n        console.log(item);\n      }\n      // [\"red\", \"red\"]\n      // [\"green\", \"green\"]\n      // [\"blue\", \"blue\"]\n      ```\n\n    - Set.prototype.forEach()\n\n      ```js\n      let set = new Set([1, 4, 9]);\n      set.forEach((value, key) => console.log(key + \" : \" + value));\n      // 1 : 1\n      // 4 : 4\n      // 9 : 9\n      ```\n\n# Map\n\n#### 概述\n\nJavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\n#### 基本用法\n\n- 作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组\n\n  ```js\n  const map = new Map([\n    [\"name\", \"张三\"],\n    [\"title\", \"Author\"],\n  ]);\n\n  map.size; // 2\n  map.has(\"name\"); // true\n  map.get(\"name\"); // \"张三\"\n  map.has(\"title\"); // true\n  map.get(\"title\"); // \"Author\"\n  ```\n\n#### 属性和方法\n\n- size 属性，`size`属性返回 Map 结构的成员总数。\n\n  ```js\n  const map = new Map();\n  map.set(\"foo\", true);\n  map.set(\"bar\", false);\n\n  map.size; // 2\n  ```\n\n- Map.prototype.set(key, value) `set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键， set()方法返回的是 set 对象可以采用链式写法\n\n  ```js\n  const m = new Map();\n\n  m.set(\"edition\", 6); // 键是字符串\n  m.set(262, \"standard\"); // 键是数值\n  m.set(undefined, \"nah\"); // 键是 undefined\n  ```\n\n- Map.prototype.get(key) `get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。\n\n  ```js\n  const m = new Map();\n\n  const hello = function () {\n    console.log(\"hello\");\n  };\n  m.set(hello, \"Hello ES6!\"); // 键是函数\n\n  m.get(hello); // Hello ES6!\n  ```\n\n- Map.prototype.has(key)`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\n\n  ```js\n  const m = new Map();\n\n  m.set(\"edition\", 6);\n  m.set(262, \"standard\");\n  m.set(undefined, \"nah\");\n\n  m.has(\"edition\"); // true\n  m.has(\"years\"); // false\n  m.has(262); // true\n  m.has(undefined); // true\n  ```\n\n* Map.prototype.delete(key)`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。\n\n  ```js\n  const m = new Map();\n  m.set(undefined, \"nah\");\n  m.has(undefined); // true\n\n  m.delete(undefined);\n  m.has(undefined); // false\n  ```\n\n* Map.prototype.clear()`clear`方法清除所有成员，没有返回值\n\n  ```js\n  let map = new Map();\n  map.set(\"foo\", true);\n  map.set(\"bar\", false);\n\n  map.size; // 2\n  map.clear();\n  map.size; // 0\n  ```\n\n#### 遍历\n\n- `Map.prototype.keys()`：返回键名的遍历器。\n\n- `Map.prototype.values()`：返回键值的遍历器\n\n- `Map.prototype.entries()`：返回所有成员的遍历器\n\n- `Map.prototype.forEach()`：遍历 Map 的所有成员\n\n  ```js\n  const map = new Map([\n    [\"F\", \"no\"],\n    [\"T\", \"yes\"],\n  ]);\n\n  for (let key of map.keys()) {\n    console.log(key);\n  }\n  // \"F\"\n  // \"T\"\n\n  for (let value of map.values()) {\n    console.log(value);\n  }\n  // \"no\"\n  // \"yes\"\n\n  for (let item of map.entries()) {\n    console.log(item[0], item[1]);\n  }\n  // \"F\" \"no\"\n  // \"T\" \"yes\"\n\n  // 或者\n  for (let [key, value] of map.entries()) {\n    console.log(key, value);\n  }\n  // \"F\" \"no\"\n  // \"T\" \"yes\"\n  map.forEach(function (value, key, map) {\n    console.log(\"Key: %s, Value: %s\", key, value);\n  });\n  ```\n\n  `forEach`方法还可以接受第二个参数，用来绑定`this`。\n\n# Symbol\n\n#### 概述\n\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。ES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）Symbol 值通过`Symbol`函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\n\n```js\nvar obj = {\n  say: \"lagou\",\n};\nvar say = Symbol(); //say 是symbol类型\nobj[say] = \"web\";\nconsole.log(obj); //{say: \"lagou\", Symbol(): \"web\"}\n```\n\n#### 语法\n\n- `Symbol`函数前不能使用`new`命令，否则会报错\n\n- `Symbol`函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分\n\n- 每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性\n\n  ```js\n  var a = Symbol();\n  var b = Symbol();\n  console.log(a === b); //false\n  var a = Symbol(\"a\");\n  var b = Symbol(\"b\");\n  console.log(a === b); //false\n  ```\n\n  注意：`Symbol`函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的`Symbol`函数的返回值是不相等的\n\n  ```js\n  var a = Symbol(\"a\");\n  var b = Symbol(\"a\");\n  console.log(a === b); //false\n  ```\n\n- Symbol 值不能与其他类型的值进行运算，会报错\n\n  ```js\n  let sym = Symbol(\"My symbol\");\n\n  \"your symbol is \" +\n    sym // TypeError: can't convert symbol to string\n    `your symbol is ${sym}`;\n  // TypeError: can't convert symbol to string\n  ```\n\n- Symbol 值作为对象属性名时，不能用点运算符\n\n  ```js\n  const mySymbol = Symbol();\n  const a = {};\n  a.mySymbol = \"Hello!\";\n  console.log(a[mySymbol]); //undefined\n  console.log(a[\"mySymbol\"]); //hello\n  ```\n\n* Symbol 作为属性名，遍历对象的时候，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols()`方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。\n\n  ```js\n  const obj = {};\n  let a = Symbol(\"a\");\n  let b = Symbol(\"b\");\n  obj[a] = \"Hello\";\n  obj[b] = \"World\";\n  const objectSymbols = Object.getOwnPropertySymbols(obj);\n  console.log(objectSymbols); //[Symbol(a), Symbol(b)]\n  ```\n\n* 有时，我们希望重新使用同一个 Symbol 值，`Symbol.for()`方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。\n\n  ```js\n  let s1 = Symbol.for(\"foo\");\n  let s2 = Symbol.for(\"foo\");\n\n  s1 === s2; // true\n  ```\n\n  `Symbol.for()`与`Symbol()`这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。`Symbol.for()`不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的`key`是否已经存在，如果不存在才会新建一个值。比如，如果你调用`Symbol.for(\"cat\")`30 次，每次都会返回同一个 Symbol 值，但是调用`Symbol(\"cat\")`30 次，会返回 30 个不同的 Symbol 值\n\n  ```js\n  Symbol.for(\"bar\") === Symbol.for(\"bar\");\n  // true\n\n  Symbol(\"bar\") === Symbol(\"bar\");\n  ```\n\n  由于`Symbol()`写法没有登记机制，所以每次调用都会返回一个不同的值。`Symbol.for()`为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行\n\n  ```js\n  function foo() {\n    return Symbol.for(\"bar\");\n  }\n\n  const x = foo();\n  const y = Symbol.for(\"bar\");\n  console.log(x === y); // true\n  ```\n\n# 可迭代接口\n\n#### Iterater 的概念\n\n- 简单介绍\n\n  JavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\n\n  遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n\n  Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。\n\n- Iterator 的遍历过程\n\n  - 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。\n\n  - 第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员\n\n  - 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员\n\n  - 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置\n\n    每一次调用`next`方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含`value`和`done`两个属性的对象。其中，`value`属性是当前成员的值，`done`属性是一个布尔值，表示遍历是否结束。\n\n    ```js\n    简单的Iterator遍历器的实现;\n    var it = easyIterator([\"a\", \"b\"]);\n\n    it.next(); // { value: \"a\", done: false }\n    it.next(); // { value: \"b\", done: false }\n    it.next(); // { value: undefined, done: true }\n\n    function easyIterator(array) {\n      var nextIndex = 0;\n      return {\n        next: function () {\n          return nextIndex < array.length\n            ? { value: array[nextIndex++], done: false }\n            : { value: undefined, done: true };\n        },\n      };\n    }\n    ```\n\n#### Iterater 接口\n\n- 字符串 数组 set map arguments 都有 iterater 接口，nodelist 集合，都可以用 for of 遍历\n\n  ```js\n  var st = \"lagou\";\n  for (i of st) {\n    console.log(i); // l a g o u\n  }\n  var arr = [1, 2];\n  for (v of arr) {\n    console.log(v); //1 2\n  }\n  function fn(a, b, c) {\n    for (i of arguments) {\n      console.log(i); //1 2 3\n    }\n  }\n  fn(1, 2, 3);\n  ```\n\n# Modules\n\n#### 概述\n\n- JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\n\n#### 语法\n\n- export\n\n  - `export`命令用于规定模块的对外接口\n\n  - 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量。下面是一个 JS 文件，里面使用`export`命令输出变量\n\n    ```javascript\n    //demo.js\n    export var firstName = \"Michael\";\n    export var lastName = \"Jackson\";\n    export var year = 1958;\n    //或者\n    var firstName = \"Michael\";\n    var lastName = \"Jackson\";\n    var year = 1958;\n\n    export { firstName, lastName, year };\n    ```\n\n- import\n\n  - `import`命令用于输入其他模块提供的功能\n\n  - `import`命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（`profile.js`）对外接口的名称相同\n\n    ```javascript\n    // main.js\n    import { firstName, lastName, year } from \"./profile.js\";\n\n    function setName(element) {\n      element.textContent = firstName + \" \" + lastName;\n    }\n    ```\n\n  -\n\n- export default\n\n  - 为了给用户提供方便，就要用到`export default`命令，为模块指定默认输出\n\n  - 本质上，`export default`就是输出一个叫做`default`的变量或方法，然后系统允许你为它取任意名字\n\n  - 在`import`命令后面，不再使用大括号\n\n  - `export default`命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此`export default`命令只能使用一次\n\n    ```javascript\n    // export-default.js\n    export default function () {\n      console.log(\"foo\");\n    }\n    ```\n\n    ```javascript\n    // import-default.js\n    import customName from \"./export-default\";\n    customName(); // 'foo'\n    ```\n\n#### 浏览器端加载实现\n\n- 浏览器加载 ES6 模块，也使用标签，但是要加入`type=\"module\"`属性\n\n  ```js\n  // 01.js\n  export var a = 123;\n  ```\n\n  ```js\n  //demo.html\n  <script type=\"module\">import {a} from \"./01.js\"; console.log(a)//123</script>\n  ```\n\n* 脚本异步加载\n\n  ```html\n  <script src=\"path/to/myModule.js\" defer></script>\n  <script src=\"path/to/myModule.js\" async></script>\n  ```\n\n  解说：上面代码中，标签打开`defer`或`async`属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。defer 与 async 的区别是：defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。\n","slug":"es6整理","published":1,"updated":"2020-09-19T08:38:58.125Z","_id":"ckf9f34bn000045lg3bnn0zxe","layout":"post","photos":[],"link":"","content":"<!--excerpt-->\n<p><strong>ECMAScript2015</strong></p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><h4 id=\"1-新的标准规范\"><a href=\"#1-新的标准规范\" class=\"headerlink\" title=\"1.新的标准规范\"></a>1.新的标准规范</h4><p>ECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。</p>\n<h4 id=\"2-ECMAScript-和-js-关系\"><a href=\"#2-ECMAScript-和-js-关系\" class=\"headerlink\" title=\"2.ECMAScript 和 js 关系\"></a>2.ECMAScript 和 js 关系</h4><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。javascript 是 netscape 创 造的并交给了国际标准化组织 ECMA，之所以不叫做 JavaScript 由于商标的问题，java 是 sun 公司的商标，根据 授权协议只有 Netscape 公司可以合法使用 JavaScript 这个名字，另外就是为了体现 JavaScript 的标准的制定者 不是 ECMA 所以取名为 ECMAScript。</p>\n<h4 id=\"3-ES6-与-ECMAScript-2015-的关系\"><a href=\"#3-ES6-与-ECMAScript-2015-的关系\" class=\"headerlink\" title=\"3.ES6 与 ECMAScript 2015 的关系\"></a>3.ES6 与 ECMAScript 2015 的关系</h4><p>ES6 是 ECMA 的为 JavaScript 制定的第 6 个版本的标准，标准委员会最终决定，标准在每年的 6 月份正式发布一 次，作为当年的正式版本。ECMAscript 2015 是在 2015 年 6 月份发布的 ES6 的第一个版本。依次类推 ECMAscript 2016 是 ES6 的第二个版本、 ECMAscript 2017 是 ES6 的第三个版本……</p>\n<h1 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h1><h4 id=\"1-块级作用域的种类\"><a href=\"#1-块级作用域的种类\" class=\"headerlink\" title=\"1.块级作用域的种类\"></a>1.块级作用域的种类</h4><p>ECMAScript2015 为 js 提出的第三个作用域，凡是带{}的都是一个块级作用域。</p>\n<p>if 语句的{},for 循环中的{},while 中的{},或者是我们单独写的{} try{}catch(error){}这些都提供了块级作用域。</p>\n<h4 id=\"块级作用域分析\"><a href=\"#块级作用域分析\" class=\"headerlink\" title=\"块级作用域分析\"></a>块级作用域分析</h4><h5 id=\"1-为什么需要块级作用域？\"><a href=\"#1-为什么需要块级作用域？\" class=\"headerlink\" title=\"1.为什么需要块级作用域？\"></a>1.为什么需要块级作用域？</h5><ul>\n<li><p>内层变量会覆盖外层变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lagou = <span class=\"string\">&quot;拉勾&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(lagou); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lagou = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>这是因为 fn 函数体内以及有 var 声明的变量 lagou，只是还没有赋值，默认为 undefined。</p>\n<ul>\n<li><p>用来计数的循环变量泄露为全局变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h5 id=\"2-块级作用域的成员\"><a href=\"#2-块级作用域的成员\" class=\"headerlink\" title=\"2.块级作用域的成员\"></a>2.块级作用域的成员</h5><p>块级作用域内的成员需要使用 let 或 const 命令定义的变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lagou = <span class=\"string\">&quot;拉勾&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(lagou); <span class=\"comment\">//拉勾</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lagou = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"let-const\"><a href=\"#let-const\" class=\"headerlink\" title=\"let const\"></a>let const</h1><h4 id=\"1-let\"><a href=\"#1-let\" class=\"headerlink\" title=\"1.let\"></a>1.let</h4><p>基本用法</p>\n<p>ECMAScript2015 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>\n<p>let 主要声明块级作用域下的成员，这个成员变量的作用域范围只能在当前块级作用域下。</p>\n<ul>\n<li>wer</li>\n<li>er</li>\n</ul>\n<h4 id=\"2-const\"><a href=\"#2-const\" class=\"headerlink\" title=\"2.const\"></a>2.const</h4><p>const 声明变量的同时必须要赋值。</p>\n<p>const 声明之后，不允许去修改它的值，这里面的值说的是不允许修改它，是声明之后不允许重新指向一个新</p>\n<p>的内存地址，可以去修改内存地址中的属性成员。</p>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><h4 id=\"1-数组的解构\"><a href=\"#1-数组的解构\" class=\"headerlink\" title=\"1.数组的解构\"></a>1.数组的解构</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p>\n<ul>\n<li><p>完全解构 将数组中的每一个值都对应上相应的变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;lagou&quot;</span>, <span class=\"string\">&quot;edu&quot;</span>, <span class=\"string\">&quot;web&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [com, ind, work] = arr;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(work); <span class=\"comment\">//web</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不完全解构 数组中的部分值对应上了相应的变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;lagou&quot;</span>, <span class=\"string\">&quot;edu&quot;</span>, <span class=\"string\">&quot;web&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [, , work] = arr;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(work); <span class=\"comment\">//web</span></span><br></pre></td></tr></table></figure>\n\n<p>注意:模式没有匹配上的可以不填，但是必须要加逗号隔开。</p>\n</li>\n</ul>\n<ul>\n<li><p>扩展运算符…</p>\n<ul>\n<li><p>展开运算符说明</p>\n<ul>\n<li><p>三个点(…)是一个展开运算符，其功能为对三个点后面的变量进行展开操作</p>\n</li>\n<li><p>三个点(…)展开运算符:只能对具有 Iterator 接口的对象进行展开操作</p>\n</li>\n<li><p>使用场景</p>\n<pre><code>![image-20200508180111209](imgs/image-20200508180111209.png)\n\n案例一\n\n&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr=[&lt;span class=&quot;string&quot;&gt;&amp;quot;拉勾&amp;quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&amp;quot;edu&amp;quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fn(...arr)&lt;span class=&quot;comment&quot;&gt;//web&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例二`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = [&lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = [&lt;span class=&quot;number&quot;&gt;101&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;102&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;103&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.push(...b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;span class=&quot;comment&quot;&gt;//[88, 99, 100, 101, 102, 103]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例三`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; d=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e:&lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩教育&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f:&lt;span class=&quot;string&quot;&gt;&amp;quot;www.lagou.com&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g:&lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;h:&lt;span class=&quot;number&quot;&gt;1100&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;attr&quot;&gt;g&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;h&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1100&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;e&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩教育&amp;quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;f&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;www.lagou.com&amp;quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例四`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; st=&lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩 edu&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr=[...st];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr)&lt;span class=&quot;comment&quot;&gt;//[&amp;quot;拉&amp;quot;, &amp;quot;钩&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;u&amp;quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`掌握了展开运算符的使用规则，我们看一下数组的特殊解构。`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [a,...b] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a)&lt;span class=&quot;comment&quot;&gt;//1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b)&lt;span class=&quot;comment&quot;&gt;//[2,3,4,5,6]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 解构不成功</span><br><span class=\"line\"></span><br><span class=\"line\">  右边的变量的个数超过了等号左边中数组的元素</span><br><span class=\"line\"></span><br><span class=\"line\">  &#96;&#96;&#96;js</span><br><span class=\"line\">  let [a, b, c] &#x3D; [12];</span><br><span class=\"line\">  console.log(b); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<p>如果解构没有成功，则变量的值是 undefined，如果是展开运算的变量则是空数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, ...c] = [<span class=\"number\">12</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"2-数组的扩展\"><a href=\"#2-数组的扩展\" class=\"headerlink\" title=\"2.数组的扩展\"></a>2.数组的扩展</h4><ul>\n<li><p>扩展运算符…</p>\n<ul>\n<li><p>扩展运算符（spread）是三个点（<code>...</code>）它好比<a href=\"#rest\"> rest 参数的逆运算</a>，将一个数组转为用逗号分隔的参数序列。</p>\n</li>\n<li><p>替代 apply()的使用技巧</p>\n<p>我们之前在求一个数组中的最大值得时候采用得方式是 Math.max.apply(null,[12,34,56,43]) ==56</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">43</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max); <span class=\"comment\">//56</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> max2 = <span class=\"built_in\">Math</span>.max(...[<span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">43</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max2); <span class=\"comment\">//56</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Array 类的扩展方法</p>\n<ul>\n<li>Array.from()</li>\n</ul>\n<p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arraylike = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"string\">&quot;lagou&quot;</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">&quot;edu&quot;</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">&quot;web&quot;</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.from(arraylike);</span><br><span class=\"line\">[<span class=\"string\">&quot;lagou&quot;</span>, <span class=\"string\">&quot;edu&quot;</span>, <span class=\"string\">&quot;web&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>Array.from 还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[1,4,9]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Array.of 方法用于将一组值，转换为数组，这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>); <span class=\"comment\">//[emptyx3]</span></span><br></pre></td></tr></table></figure>\n\n<p>这里面 3 表示数组中元素的长度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>); <span class=\"comment\">//[2,3,4]</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>Array()</code>里的参数个数大于 1 的时候，表示的是数组元素。</p>\n<p><code>Array.of()</code>方法不管里面参数的个数多少，都将其转为数组的元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[3]</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><h4 id=\"1-对象中有关变量的解构赋值\"><a href=\"#1-对象中有关变量的解构赋值\" class=\"headerlink\" title=\"1.对象中有关变量的解构赋值\"></a>1.对象中有关变量的解构赋值</h4><p>解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; name, work &#125; = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;lagou&quot;</span>, <span class=\"attr\">work</span>: <span class=\"string\">&quot;web&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name, work); <span class=\"comment\">//lagou web</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-对象的扩展\"><a href=\"#2-对象的扩展\" class=\"headerlink\" title=\"2.对象的扩展\"></a>2.对象的扩展</h4><ul>\n<li><p>对象的简写</p>\n<ul>\n<li><p>当变量名和属性名同名式，省略同名的属性值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123; foo &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123; <span class=\"attr\">foo</span>: foo &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>省略方法中的 function</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  method() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;拉勾!&quot;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;拉勾!&quot;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>属性的赋值器（setter）和取值器（getter）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lagou = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;拉勾&quot;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">com</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">work</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"built_in\">this</span>.name + value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lagou.com); <span class=\"comment\">//拉勾</span></span><br><span class=\"line\">lagou.work = <span class=\"string\">&quot;招聘&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lagou.name); <span class=\"comment\">//拉勾招聘</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>属性名表达式</p>\n<p>es5 中定义对象的属性有两种方法，一种是用标识符做属性，一种是用表达式做属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法一;</span><br><span class=\"line\">obj.name = <span class=\"string\">&quot;拉勾&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\">obj[<span class=\"string\">&quot;name&quot;</span>] = <span class=\"string\">&quot;拉勾&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lagou = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;拉勾&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用大括号定义对象，那么在 es5 中只能使用标识符定义属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lagou = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;拉勾&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>但是 ECMAScript2015 在使用大括号定义对象的时候，允许使用表达式定义属性，把表达式放在方括号中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">&quot;lagou&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> lagou = &#123;</span><br><span class=\"line\">  [name]: <span class=\"string\">&quot;web&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lagou); <span class=\"comment\">//&#123;lagou: &quot;web&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-三点运算在对象中的用途\"><a href=\"#3-三点运算在对象中的用途\" class=\"headerlink\" title=\"3.三点运算在对象中的用途\"></a>3.三点运算在对象中的用途</h4><ul>\n<li><p>用于对象的解构</p>\n<ul>\n<li><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; x, y, ...z &#125; = &#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">b</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(z); <span class=\"comment\">//&#123;a: 3, b: 4&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p>\n<pre><code>注意:1.解构赋值必须是最后一个参数。2.解构赋值的拷贝是浅拷贝。</code></pre>\n</li>\n</ul>\n</li>\n<li><p>用于扩展运算</p>\n<ul>\n<li><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> z = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;lagou&quot;</span>, <span class=\"attr\">work</span>: <span class=\"string\">&quot;web&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n = &#123; ...z &#125;;</span><br><span class=\"line\">n; <span class=\"comment\">// &#123; name: &quot;lagou&quot;, work: &quot;web&quot; &#125;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><h4 id=\"1-字符串模板\"><a href=\"#1-字符串模板\" class=\"headerlink\" title=\"1.字符串模板\"></a>1.字符串模板</h4><ul>\n<li><p>传统的字符串里不能使用换行符，必须使用转义符\\n 替代，字符串模板里可以使用。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>\n</li>\n<li><p>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&quot;拉勾&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"string\">`欢迎来到<span class=\"subst\">$&#123;name&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(st);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"2-标签模板\"><a href=\"#2-标签模板\" class=\"headerlink\" title=\"2.标签模板\"></a>2.标签模板</h4><ul>\n<li><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log<span class=\"string\">`hello`</span>;</span><br><span class=\"line\">等同于;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"string\">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>\n<p>注意:如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">&quot;laogou&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> work=<span class=\"string\">&quot;web&quot;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tag</span>(<span class=\"params\">st,a,b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(st);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(b)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello lagou&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> st=tag<span class=\"string\">`hello<span class=\"subst\">$&#123;name&#125;</span>,职业<span class=\"subst\">$&#123;work&#125;</span>开发`</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(st)<span class=\"comment\">//hello lagou</span></span><br><span class=\"line\">[<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;,职业&quot;</span>, <span class=\"string\">&quot;开发&quot;</span>, <span class=\"attr\">raw</span>: <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>)]</span><br><span class=\"line\">laogou</span><br><span class=\"line\">web</span><br></pre></td></tr></table></figure>\n\n<p>函数内的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&quot;laogou&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> work = <span class=\"string\">&quot;web&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tag</span>(<span class=\"params\">st, a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(st);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello lagou&quot;</span>; <span class=\"comment\">//如果没有返回值，则默认是undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> st = tag<span class=\"string\">`hello<span class=\"subst\">$&#123;name&#125;</span>,职业<span class=\"subst\">$&#123;work&#125;</span>开发`</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(st); <span class=\"comment\">//hello lagou</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"3-扩展的方法\"><a href=\"#3-扩展的方法\" class=\"headerlink\" title=\"3.扩展的方法\"></a>3.扩展的方法</h4><ul>\n<li><p>字符串实例的方法</p>\n<ul>\n<li><p><strong>includes()</strong></p>\n<p>返回布尔值，表示是否找到了参数字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"string\">&quot;lagou web&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = st.includes(<span class=\"string\">&quot;web&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>startsWith()</strong></p>\n<p>返回布尔值，表示参数字符串是否在原字符串的头部</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"string\">&quot;lagou web&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = st.startsWith(<span class=\"string\">&quot;la&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>endsWith()</strong></p>\n<p>返回布尔值，表示参数字符串是否在原字符串的尾部</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"string\">&quot;lagou web&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = st.endsWith(<span class=\"string\">&quot;web&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><h4 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h4><ul>\n<li><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a, b = <span class=\"string\">&quot; lagou &quot;</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(<span class=\"string\">&quot;hello&quot;</span>); <span class=\"comment\">//hello lagou</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意:</p>\n<ul>\n<li>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明.</li>\n<li>使用参数默认值时，函数不能有同名参数</li>\n</ul>\n</li>\n<li><p>参数默认值的位置</p>\n<ul>\n<li><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x = <span class=\"number\">1</span>, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// [1, undefined]</span></span><br><span class=\"line\">f(<span class=\"number\">2</span>) <span class=\"comment\">// [2, undefined]</span></span><br><span class=\"line\">f(, <span class=\"number\">1</span>) <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"rest-参数\"><a href=\"#rest-参数\" class=\"headerlink\" title=\"rest 参数\"></a><span name=\"app\">rest 参数</span></h4><ul>\n<li><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">...values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(values);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>); <span class=\"comment\">// [2, 5, 3]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>rest 参数和函数中的参数解构有什么区别</p>\n<ul>\n<li>rest 参数是发生在函数的定义阶段，函数的额参数解构是发生在函数的调用阶段</li>\n<li>二者是一种互为逆运算</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">...values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这是rest参数</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(values);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>); <span class=\"comment\">// [2, 5, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a + b + c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(...arr); <span class=\"comment\">//6  这是参数的解构</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><ul>\n<li>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> v;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\">() =&gt;</span> <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getItem = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> &#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">name</span>: <span class=\"string\">&quot;Temp&quot;</span> &#125;; <span class=\"comment\">//报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> getItem = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> (&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">name</span>: <span class=\"string\">&quot;Temp&quot;</span> &#125;);<span class=\"comment\">//不报错</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>箭头函数有几个使用注意点<ul>\n<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数外面的 this 是什么，箭头函数内的 this 还是什么。</li>\n<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li>\n<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">&quot;web&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">    name:<span class=\"string\">&quot;lagou&quot;</span>,</span><br><span class=\"line\">    fn()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t=<span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)<span class=\"comment\">//web  this是window</span></span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.fn()</span><br><span class=\"line\">-----------------------------------</span><br><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">&quot;web&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">    name:<span class=\"string\">&quot;lagou&quot;</span>,</span><br><span class=\"line\">    fn()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t=<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)<span class=\"comment\">//lagou this是obj</span></span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.fn()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><h4 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h4><ul>\n<li><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">123</span>,</span><br><span class=\"line\">  b: <span class=\"number\">123</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> sourcel = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">456</span>,</span><br><span class=\"line\">  c: <span class=\"number\">456</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = <span class=\"built_in\">Object</span>.assign(target, sourcel);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target); <span class=\"comment\">//&#123;a: 456, b: 123, c: 456&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target === result); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果目标对象与源对象有同名属性，则后面的属性会覆盖前面的属性。且<code>assign()</code>的返回值就是第一个对象。</p>\n<p>如果有多个源对象有同名属性，依然是后面的会覆盖前面的属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source2 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(target, source1, source2);</span><br><span class=\"line\">target; <span class=\"comment\">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>利用<code>Object.assign()</code>复制一个对象，且其中一个对象的修改不会影响到另一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sourcel = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">123</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, sourcel);</span><br><span class=\"line\">obj.a = <span class=\"number\">456</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">//&#123;a: 456&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sourcel); <span class=\"comment\">//&#123;a: 123&#125;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a>Object.is()</h4><ul>\n<li><p><code>Object.is</code>就是用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(+<span class=\"number\">0</span>, <span class=\"number\">-0</span>)); <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"number\">0</span> === <span class=\"number\">-0</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h1><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Proxy 可以理解成一个快递员，我们发快递还是接受快递，都需要这个快递员充当一个代理的作用。ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例，这个实例就是一个代理对象（快递员）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"目标对象\"><a href=\"#目标对象\" class=\"headerlink\" title=\"目标对象\"></a>目标对象</h4><p>这个代理对象有两个参数，一个是代理的目标对象，第二个也是一个对象，它是配置对象，用来定制代理的拦截行为。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;zce&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> personProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(person, &#123;</span><br><span class=\"line\">  get(target, property) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(target, property); <span class=\"comment\">//person&#123;name:&quot;zce&quot;,age:20&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set() &#123;&#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置对象\"><a href=\"#配置对象\" class=\"headerlink\" title=\"配置对象\"></a>配置对象</h4><ul>\n<li><p>配置对象中一般有两个方法<code>get</code>和<code>set</code>,<code>get</code>是用来拦截对目标对象属性的访问请求。<code>get</code>方法中有两个参数，第一个参数是目标对象，第二个参数是访问的那个属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;zce&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> personProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(person, &#123;</span><br><span class=\"line\">  get(target, property) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(target, property);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set() &#123;&#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(personProxy.name); <span class=\"comment\">//100</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>注意，这个<code>get</code>方法的返回值就是我们获取的这个属性的返回值。</p>\n<ul>\n<li><p>这个<code>get</code>方法中有三个参数，一个是代理的目标对象，一个是代理的处理对象，第三个参数是 proxy 实例本身，且第三个参数是可选参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;zce&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> personProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(person, &#123;</span><br><span class=\"line\">  get(target, property, o) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(o); <span class=\"comment\">//proxy&#123;name:&quot;zec&quot;,age:20&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> property <span class=\"keyword\">in</span> target ? target[property] : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set() &#123;&#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(personProxy.age); <span class=\"comment\">//20</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这个<code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;zce&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> personProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(person, &#123;</span><br><span class=\"line\">  get(target, property, o) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> property <span class=\"keyword\">in</span> target ? target[property] : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set(obj, pro, value, o) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(obj, pro, value, o);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((personProxy.name = <span class=\"string\">&quot;zhang&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//&#123;name: &quot;zce&quot;, age: 20&#125; &quot;name&quot; &quot;zhang&quot; Proxy &#123;name: &quot;zce&quot;, age: 20&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以去设置一些属性或修改</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;zce&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> personProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(person, &#123;</span><br><span class=\"line\">  get(target, property, o) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> property <span class=\"keyword\">in</span> target ? target[property] : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set(target, pro, value, o) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//可以做一些内部校验</span></span><br><span class=\"line\">    target[pro] = value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((personProxy.name = <span class=\"string\">&quot;lagou&quot;</span>));</span><br><span class=\"line\">person; <span class=\"comment\">//&#123;name:&quot;lagou&quot;,age:20&#125;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h1><h4 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\n<ul>\n<li><p>将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法</p>\n</li>\n<li><p>修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(target, property, attributes);</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"string\">&quot;assign&quot;</span> <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.has(<span class=\"built_in\">Object</span>, <span class=\"string\">&quot;assign&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h4><ul>\n<li><p>Reflect.get</p>\n<ul>\n<li><p><code>Reflect.get(target, name, receiver)</code>,<code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">baz</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.foo + <span class=\"built_in\">this</span>.bar;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(myObject, <span class=\"string\">&quot;foo&quot;</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(myObject, <span class=\"string\">&quot;bar&quot;</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(myObject, <span class=\"string\">&quot;baz&quot;</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">baz</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.foo + <span class=\"built_in\">this</span>.bar;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myReceiverObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">4</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">4</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(myObject, <span class=\"string\">&quot;baz&quot;</span>, myReceiverObject); <span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(<span class=\"number\">1</span>, <span class=\"string\">&quot;foo&quot;</span>); <span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(<span class=\"literal\">false</span>, <span class=\"string\">&quot;foo&quot;</span>); <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Reflect.set</p>\n<ul>\n<li><p><code>Reflect.set(target, name, value, receiver)</code>,<code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.foo; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.set(myObject, <span class=\"string\">&quot;foo&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">myObject.foo; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">4</span>,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">bar</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">this</span>.foo = value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myReceiverObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">0</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.set(myObject, <span class=\"string\">&quot;bar&quot;</span>, <span class=\"number\">1</span>, myReceiverObject);</span><br><span class=\"line\">myObject.foo; <span class=\"comment\">// 4</span></span><br><span class=\"line\">myReceiverObject.foo; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Reflect.has</p>\n<ul>\n<li><p><code>Reflect.has(obj, name)</code>,<code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 旧写法</span></span><br><span class=\"line\"><span class=\"string\">&quot;foo&quot;</span> <span class=\"keyword\">in</span> myObject; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.has(myObject, <span class=\"string\">&quot;foo&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p>\n</li>\n</ul>\n</li>\n<li><p>Reflect.deleteProperty</p>\n<ul>\n<li><p>Reflect.deleteProperty(obj, name),<code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myObj = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">&quot;bar&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 旧写法</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> myObj.foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.deleteProperty(myObj, <span class=\"string\">&quot;foo&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><h4 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\n<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n<h4 id=\"promise-特点\"><a href=\"#promise-特点\" class=\"headerlink\" title=\"promise 特点\"></a>promise 特点</h4><p><code>Promise</code>对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>\n<h4 id=\"promise-使用方法\"><a href=\"#promise-使用方法\" class=\"headerlink\" title=\"promise 使用方法\"></a>promise 使用方法</h4><ul>\n<li><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>\n</li>\n<li><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    resolve(data);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n</li>\n<li><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.then(</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success业务处理</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>\n<ul>\n<li><p>看一个简单的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">time</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">time(<span class=\"number\">1000</span>).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Promise 新建后就会立即执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Promise&quot;</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;resolved.&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Hi!&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//Promise</span></span><br><span class=\"line\"><span class=\"comment\">//Hi</span></span><br><span class=\"line\"><span class=\"comment\">//resolved</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h1><h4 id=\"概述-3\"><a href=\"#概述-3\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;(&quot;</span> + <span class=\"built_in\">this</span>.x + <span class=\"string\">&quot;, &quot;</span> + <span class=\"built_in\">this</span>.y + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h4><ul>\n<li><p><code>constructor()</code></p>\n<ul>\n<li><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</li>\n</ul>\n</li>\n<li><p>类的实例</p>\n<ul>\n<li><p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;(&quot;</span> + <span class=\"built_in\">this</span>.x + <span class=\"string\">&quot;, &quot;</span> + <span class=\"built_in\">this</span>.y + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">point.toString(); <span class=\"comment\">// (2, 3)</span></span><br><span class=\"line\"></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">&quot;x&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">&quot;y&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">&quot;toString&quot;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\">point.__proto__.hasOwnProperty(<span class=\"string\">&quot;toString&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>与 ES5 一样，类的所有实例共享一个原型对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">p1.__proto__ === p2.__proto__;</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>getter 和 setter</p>\n<ul>\n<li><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">prop</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;getter&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">prop</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;setter: &quot;</span> + value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> inst = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"></span><br><span class=\"line\">inst.prop = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"comment\">// setter: 123</span></span><br><span class=\"line\"></span><br><span class=\"line\">inst.prop;</span><br><span class=\"line\"><span class=\"comment\">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>属性表达式</p>\n<ul>\n<li><p>类的属性名，可以采用表达式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> methodName = <span class=\"string\">&quot;getArea&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(length) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [methodName]() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h4><ul>\n<li><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.classMethod(); <span class=\"comment\">// &#x27;hello&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">foo.classMethod();</span><br><span class=\"line\"><span class=\"comment\">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>\n\n<p>解说：上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>\n</li>\n<li><p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> bar() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.baz();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> baz() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  baz() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.bar(); <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<p>解说：上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p>\n</li>\n<li><p>父类的静态方法，可以被子类继承</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Bar.classMethod(); <span class=\"comment\">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>静态属性</p>\n<p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性</p>\n<p>ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a href=\"https://github.com/tc39/proposal-class-fields\">提案</a>提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> myStaticProp = <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(MyClass.myStaticProp); <span class=\"comment\">// 42</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><ul>\n<li><p>简介</p>\n<ul>\n<li><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解说：上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类</p>\n</li>\n<li><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cp = <span class=\"keyword\">new</span> ColorPoint(); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y, color) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = color; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">    <span class=\"built_in\">super</span>(x, y);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = color; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>super</p>\n<ul>\n<li><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同</p>\n<ul>\n<li><p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解说：上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B的实例，因此</code>super()<code>在这里相当于</code>A.prototype.constructor.call(this)`</p>\n</li>\n<li><p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  p() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">super</span>.p()); <span class=\"comment\">// 2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由于<code>super</code>指向父类的原型对象(prototype)，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.p = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">m</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">b.m; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h1><h4 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><ul>\n<li><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n</li>\n<li><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>\n</li>\n<li><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set); <span class=\"comment\">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>数组去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...new <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])]; <span class=\"comment\">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...new <span class=\"built_in\">Set</span>(<span class=\"string\">&quot;ababbc&quot;</span>)].join(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">//&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"属性和方法\"><a href=\"#属性和方法\" class=\"headerlink\" title=\"属性和方法\"></a>属性和方法</h4><ul>\n<li><p>Set 结构的实例有以下属性。</p>\n<ul>\n<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>\n<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>\n</ul>\n</li>\n<li><p>Set 实例的方法分为两大类</p>\n<ul>\n<li><p>操作方法（用于操作数据）</p>\n<ul>\n<li><p><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([]);</span><br><span class=\"line\">items.add(<span class=\"number\">1</span>).add(<span class=\"number\">2</span>).add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(items); <span class=\"comment\">//[1,2,3]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">12</span>, <span class=\"number\">23</span>, <span class=\"number\">34</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = items.delete(<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items); <span class=\"comment\">//Set(2) &#123;23, 34&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</p>\n</li>\n<li><p><code>Set.prototype.clear()</code>：清除所有成员，没有返回值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">12</span>, <span class=\"number\">23</span>, <span class=\"number\">34</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = items.clear(<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items); <span class=\"comment\">//Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>遍历方法（用于遍历成员）</p>\n<ul>\n<li><p><code>Set.prototype.keys()</code>：返回键名的遍历器</p>\n</li>\n<li><p><code>Set.prototype.values()</code>：返回键值的遍历器</p>\n</li>\n<li><p>Set.prototype.entries()</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;green&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>]);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Set.prototype.forEach()</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>]);</span><br><span class=\"line\">set.forEach(<span class=\"function\">(<span class=\"params\">value, key</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(key + <span class=\"string\">&quot; : &quot;</span> + value));</span><br><span class=\"line\"><span class=\"comment\">// 1 : 1</span></span><br><span class=\"line\"><span class=\"comment\">// 4 : 4</span></span><br><span class=\"line\"><span class=\"comment\">// 9 : 9</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h1><h4 id=\"概述-4\"><a href=\"#概述-4\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<h4 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><ul>\n<li><p>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&quot;title&quot;</span>, <span class=\"string\">&quot;Author&quot;</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">map.has(<span class=\"string\">&quot;name&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.get(<span class=\"string\">&quot;name&quot;</span>); <span class=\"comment\">// &quot;张三&quot;</span></span><br><span class=\"line\">map.has(<span class=\"string\">&quot;title&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.get(<span class=\"string\">&quot;title&quot;</span>); <span class=\"comment\">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"属性和方法-1\"><a href=\"#属性和方法-1\" class=\"headerlink\" title=\"属性和方法\"></a>属性和方法</h4><ul>\n<li><p>size 属性，<code>size</code>属性返回 Map 结构的成员总数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;foo&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;bar&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map.prototype.set(key, value) <code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键， set()方法返回的是 set 对象可以采用链式写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(<span class=\"string\">&quot;edition&quot;</span>, <span class=\"number\">6</span>); <span class=\"comment\">// 键是字符串</span></span><br><span class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">&quot;standard&quot;</span>); <span class=\"comment\">// 键是数值</span></span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>); <span class=\"comment\">// 键是 undefined</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map.prototype.get(key) <code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">m.set(hello, <span class=\"string\">&quot;Hello ES6!&quot;</span>); <span class=\"comment\">// 键是函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.get(hello); <span class=\"comment\">// Hello ES6!</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map.prototype.has(key)<code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(<span class=\"string\">&quot;edition&quot;</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">&quot;standard&quot;</span>);</span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">m.has(<span class=\"string\">&quot;edition&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(<span class=\"string\">&quot;years&quot;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\">m.has(<span class=\"number\">262</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>Map.prototype.delete(key)<code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>);</span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.delete(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map.prototype.clear()<code>clear</code>方法清除所有成员，没有返回值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;foo&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;bar&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">map.clear();</span><br><span class=\"line\">map.size; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><ul>\n<li><p><code>Map.prototype.keys()</code>：返回键名的遍历器。</p>\n</li>\n<li><p><code>Map.prototype.values()</code>：返回键值的遍历器</p>\n</li>\n<li><p><code>Map.prototype.entries()</code>：返回所有成员的遍历器</p>\n</li>\n<li><p><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">&quot;F&quot;</span>, <span class=\"string\">&quot;no&quot;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&quot;T&quot;</span>, <span class=\"string\">&quot;yes&quot;</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">of</span> map.keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;F&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;T&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> map.values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;no&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;yes&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> map.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item[<span class=\"number\">0</span>], item[<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;F&quot; &quot;no&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;F&quot; &quot;no&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class=\"line\">map.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, key, map</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>\n</li>\n</ul>\n<h1 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h1><h4 id=\"概述-5\"><a href=\"#概述-5\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  say: <span class=\"string\">&quot;lagou&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> say = <span class=\"built_in\">Symbol</span>(); <span class=\"comment\">//say 是symbol类型</span></span><br><span class=\"line\">obj[say] = <span class=\"string\">&quot;web&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">//&#123;say: &quot;lagou&quot;, Symbol(): &quot;web&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><ul>\n<li><p><code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错</p>\n</li>\n<li><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分</p>\n</li>\n<li><p>每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Symbol 值不能与其他类型的值进行运算，会报错</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;My symbol&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;your symbol is &quot;</span> +</span><br><span class=\"line\">  sym <span class=\"comment\">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class=\"line\">  <span class=\"string\">`your symbol is <span class=\"subst\">$&#123;sym&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"comment\">// TypeError: can&#x27;t convert symbol to string</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Symbol 值作为对象属性名时，不能用点运算符</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;&#125;;</span><br><span class=\"line\">a.mySymbol = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[mySymbol]); <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[<span class=\"string\">&quot;mySymbol&quot;</span>]); <span class=\"comment\">//hello</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">obj[a] = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">obj[b] = <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> objectSymbols = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols); <span class=\"comment\">//[Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">s1 === s2; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;bar&quot;</span>) === <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;bar&quot;</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> x = foo();</span><br><span class=\"line\"><span class=\"keyword\">const</span> y = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x === y); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"可迭代接口\"><a href=\"#可迭代接口\" class=\"headerlink\" title=\"可迭代接口\"></a>可迭代接口</h1><h4 id=\"Iterater-的概念\"><a href=\"#Iterater-的概念\" class=\"headerlink\" title=\"Iterater 的概念\"></a>Iterater 的概念</h4><ul>\n<li><p>简单介绍</p>\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\n<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>\n<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>\n</li>\n<li><p>Iterator 的遍历过程</p>\n<ul>\n<li><p>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>\n</li>\n<li><p>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员</p>\n</li>\n<li><p>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员</p>\n</li>\n<li><p>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置</p>\n<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单的Iterator遍历器的实现;</span><br><span class=\"line\"><span class=\"keyword\">var</span> it = easyIterator([<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">easyIterator</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nextIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    next: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextIndex &lt; array.length</span><br><span class=\"line\">        ? &#123; <span class=\"attr\">value</span>: array[nextIndex++], <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">        : &#123; <span class=\"attr\">value</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Iterater-接口\"><a href=\"#Iterater-接口\" class=\"headerlink\" title=\"Iterater 接口\"></a>Iterater 接口</h4><ul>\n<li><p>字符串 数组 set map arguments 都有 iterater 接口，nodelist 集合，都可以用 for of 遍历</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"string\">&quot;lagou&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> st) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// l a g o u</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (v <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//1 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> <span class=\"built_in\">arguments</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">//1 2 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h1><h4 id=\"概述-6\"><a href=\"#概述-6\" class=\"headerlink\" title=\"概述\"></a>概述</h4><ul>\n<li>JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li>\n</ul>\n<h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><ul>\n<li><p>export</p>\n<ul>\n<li><p><code>export</code>命令用于规定模块的对外接口</p>\n</li>\n<li><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> firstName = <span class=\"string\">&quot;Michael&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> lastName = <span class=\"string\">&quot;Jackson&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> year = <span class=\"number\">1958</span>;</span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstName = <span class=\"string\">&quot;Michael&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> lastName = <span class=\"string\">&quot;Jackson&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> year = <span class=\"number\">1958</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>import</p>\n<ul>\n<li><p><code>import</code>命令用于输入其他模块提供的功能</p>\n</li>\n<li><p><code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; firstName, lastName, year &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./profile.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setName</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  element.textContent = firstName + <span class=\"string\">&quot; &quot;</span> + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>-</p>\n</li>\n<li><p>export default</p>\n<ul>\n<li><p>为了给用户提供方便，就要用到<code>export default</code>命令，为模块指定默认输出</p>\n</li>\n<li><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字</p>\n</li>\n<li><p>在<code>import</code>命令后面，不再使用大括号</p>\n</li>\n<li><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export-default.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import-default.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> customName <span class=\"keyword\">from</span> <span class=\"string\">&quot;./export-default&quot;</span>;</span><br><span class=\"line\">customName(); <span class=\"comment\">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"浏览器端加载实现\"><a href=\"#浏览器端加载实现\" class=\"headerlink\" title=\"浏览器端加载实现\"></a>浏览器端加载实现</h4><ul>\n<li><p>浏览器加载 ES6 模块，也使用标签，但是要加入<code>type=&quot;module&quot;</code>属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 01.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//demo.html</span></span><br><span class=\"line\">&lt;script type=<span class=\"string\">&quot;module&quot;</span>&gt;<span class=\"keyword\">import</span> &#123;a&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./01.js&quot;</span>; <span class=\"built_in\">console</span>.log(a)<span class=\"comment\">//123&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>脚本异步加载</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;path/to/myModule.js&quot;</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;path/to/myModule.js&quot;</span> <span class=\"attr\">async</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解说：上面代码中，标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。defer 与 async 的区别是：defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。</p>\n</li>\n</ul>","site":{"data":{}},"thumbnailImageUrl":"https://res.cloudinary.com/ddb5vwne6/image/upload/v1597758372/timg_fy8o3h.jpg","excerpt":"<p>ECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。</p>","more":"<p>ECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。</p>\n<!--excerpt-->\n<p><strong>ECMAScript2015</strong></p>\n<h1 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h1><h4 id=\"1-新的标准规范\"><a href=\"#1-新的标准规范\" class=\"headerlink\" title=\"1.新的标准规范\"></a>1.新的标准规范</h4><p>ECMAScript2015 是 js 的一种的新的标准规范，就是对 js 的写法上提出了新的语法要求和写法格式。</p>\n<h4 id=\"2-ECMAScript-和-js-关系\"><a href=\"#2-ECMAScript-和-js-关系\" class=\"headerlink\" title=\"2.ECMAScript 和 js 关系\"></a>2.ECMAScript 和 js 关系</h4><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。javascript 是 netscape 创 造的并交给了国际标准化组织 ECMA，之所以不叫做 JavaScript 由于商标的问题，java 是 sun 公司的商标，根据 授权协议只有 Netscape 公司可以合法使用 JavaScript 这个名字，另外就是为了体现 JavaScript 的标准的制定者 不是 ECMA 所以取名为 ECMAScript。</p>\n<h4 id=\"3-ES6-与-ECMAScript-2015-的关系\"><a href=\"#3-ES6-与-ECMAScript-2015-的关系\" class=\"headerlink\" title=\"3.ES6 与 ECMAScript 2015 的关系\"></a>3.ES6 与 ECMAScript 2015 的关系</h4><p>ES6 是 ECMA 的为 JavaScript 制定的第 6 个版本的标准，标准委员会最终决定，标准在每年的 6 月份正式发布一 次，作为当年的正式版本。ECMAscript 2015 是在 2015 年 6 月份发布的 ES6 的第一个版本。依次类推 ECMAscript 2016 是 ES6 的第二个版本、 ECMAscript 2017 是 ES6 的第三个版本……</p>\n<h1 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h1><h4 id=\"1-块级作用域的种类\"><a href=\"#1-块级作用域的种类\" class=\"headerlink\" title=\"1.块级作用域的种类\"></a>1.块级作用域的种类</h4><p>ECMAScript2015 为 js 提出的第三个作用域，凡是带{}的都是一个块级作用域。</p>\n<p>if 语句的{},for 循环中的{},while 中的{},或者是我们单独写的{} try{}catch(error){}这些都提供了块级作用域。</p>\n<h4 id=\"块级作用域分析\"><a href=\"#块级作用域分析\" class=\"headerlink\" title=\"块级作用域分析\"></a>块级作用域分析</h4><h5 id=\"1-为什么需要块级作用域？\"><a href=\"#1-为什么需要块级作用域？\" class=\"headerlink\" title=\"1.为什么需要块级作用域？\"></a>1.为什么需要块级作用域？</h5><ul>\n<li><p>内层变量会覆盖外层变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lagou = <span class=\"string\">&quot;拉勾&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(lagou); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lagou = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>这是因为 fn 函数体内以及有 var 声明的变量 lagou，只是还没有赋值，默认为 undefined。</p>\n<ul>\n<li><p>用来计数的循环变量泄露为全局变量</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h5 id=\"2-块级作用域的成员\"><a href=\"#2-块级作用域的成员\" class=\"headerlink\" title=\"2.块级作用域的成员\"></a>2.块级作用域的成员</h5><p>块级作用域内的成员需要使用 let 或 const 命令定义的变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lagou = <span class=\"string\">&quot;拉勾&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(lagou); <span class=\"comment\">//拉勾</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> lagou = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"let-const\"><a href=\"#let-const\" class=\"headerlink\" title=\"let const\"></a>let const</h1><h4 id=\"1-let\"><a href=\"#1-let\" class=\"headerlink\" title=\"1.let\"></a>1.let</h4><p>基本用法</p>\n<p>ECMAScript2015 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>\n<p>let 主要声明块级作用域下的成员，这个成员变量的作用域范围只能在当前块级作用域下。</p>\n<ul>\n<li>wer</li>\n<li>er</li>\n</ul>\n<h4 id=\"2-const\"><a href=\"#2-const\" class=\"headerlink\" title=\"2.const\"></a>2.const</h4><p>const 声明变量的同时必须要赋值。</p>\n<p>const 声明之后，不允许去修改它的值，这里面的值说的是不允许修改它，是声明之后不允许重新指向一个新</p>\n<p>的内存地址，可以去修改内存地址中的属性成员。</p>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><h4 id=\"1-数组的解构\"><a href=\"#1-数组的解构\" class=\"headerlink\" title=\"1.数组的解构\"></a>1.数组的解构</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p>\n<ul>\n<li><p>完全解构 将数组中的每一个值都对应上相应的变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;lagou&quot;</span>, <span class=\"string\">&quot;edu&quot;</span>, <span class=\"string\">&quot;web&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [com, ind, work] = arr;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(work); <span class=\"comment\">//web</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不完全解构 数组中的部分值对应上了相应的变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;lagou&quot;</span>, <span class=\"string\">&quot;edu&quot;</span>, <span class=\"string\">&quot;web&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [, , work] = arr;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(work); <span class=\"comment\">//web</span></span><br></pre></td></tr></table></figure>\n\n<p>注意:模式没有匹配上的可以不填，但是必须要加逗号隔开。</p>\n</li>\n</ul>\n<ul>\n<li><p>扩展运算符…</p>\n<ul>\n<li><p>展开运算符说明</p>\n<ul>\n<li><p>三个点(…)是一个展开运算符，其功能为对三个点后面的变量进行展开操作</p>\n</li>\n<li><p>三个点(…)展开运算符:只能对具有 Iterator 接口的对象进行展开操作</p>\n</li>\n<li><p>使用场景</p>\n<pre><code>![image-20200508180111209](imgs/image-20200508180111209.png)\n\n案例一\n\n&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr=[&lt;span class=&quot;string&quot;&gt;&amp;quot;拉勾&amp;quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&amp;quot;edu&amp;quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fn(...arr)&lt;span class=&quot;comment&quot;&gt;//web&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例二`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = [&lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = [&lt;span class=&quot;number&quot;&gt;101&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;102&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;103&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.push(...b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;span class=&quot;comment&quot;&gt;//[88, 99, 100, 101, 102, 103]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例三`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; d=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;e:&lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩教育&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f:&lt;span class=&quot;string&quot;&gt;&amp;quot;www.lagou.com&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;g:&lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;h:&lt;span class=&quot;number&quot;&gt;1100&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;attr&quot;&gt;g&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;web&amp;quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;h&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1100&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;e&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩教育&amp;quot;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;f&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;quot;www.lagou.com&amp;quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`案例四`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; st=&lt;span class=&quot;string&quot;&gt;&amp;quot;拉钩 edu&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr=[...st];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr)&lt;span class=&quot;comment&quot;&gt;//[&amp;quot;拉&amp;quot;, &amp;quot;钩&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;u&amp;quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;`掌握了展开运算符的使用规则，我们看一下数组的特殊解构。`&lt;/span&gt;js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; [a,...b] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a)&lt;span class=&quot;comment&quot;&gt;//1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b)&lt;span class=&quot;comment&quot;&gt;//[2,3,4,5,6]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 解构不成功</span><br><span class=\"line\"></span><br><span class=\"line\">  右边的变量的个数超过了等号左边中数组的元素</span><br><span class=\"line\"></span><br><span class=\"line\">  &#96;&#96;&#96;js</span><br><span class=\"line\">  let [a, b, c] &#x3D; [12];</span><br><span class=\"line\">  console.log(b); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<p>如果解构没有成功，则变量的值是 undefined，如果是展开运算的变量则是空数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, ...c] = [<span class=\"number\">12</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c); <span class=\"comment\">//[]</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"2-数组的扩展\"><a href=\"#2-数组的扩展\" class=\"headerlink\" title=\"2.数组的扩展\"></a>2.数组的扩展</h4><ul>\n<li><p>扩展运算符…</p>\n<ul>\n<li><p>扩展运算符（spread）是三个点（<code>...</code>）它好比<a href=\"#rest\"> rest 参数的逆运算</a>，将一个数组转为用逗号分隔的参数序列。</p>\n</li>\n<li><p>替代 apply()的使用技巧</p>\n<p>我们之前在求一个数组中的最大值得时候采用得方式是 Math.max.apply(null,[12,34,56,43]) ==56</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">43</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max); <span class=\"comment\">//56</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> max2 = <span class=\"built_in\">Math</span>.max(...[<span class=\"number\">12</span>, <span class=\"number\">34</span>, <span class=\"number\">56</span>, <span class=\"number\">43</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max2); <span class=\"comment\">//56</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Array 类的扩展方法</p>\n<ul>\n<li>Array.from()</li>\n</ul>\n<p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arraylike = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"string\">&quot;lagou&quot;</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">&quot;edu&quot;</span>,</span><br><span class=\"line\">  <span class=\"number\">2</span>: <span class=\"string\">&quot;web&quot;</span>,</span><br><span class=\"line\">  length: <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.from(arraylike);</span><br><span class=\"line\">[<span class=\"string\">&quot;lagou&quot;</span>, <span class=\"string\">&quot;edu&quot;</span>, <span class=\"string\">&quot;web&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>Array.from 还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[1,4,9]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Array.of 方法用于将一组值，转换为数组，这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>); <span class=\"comment\">//[emptyx3]</span></span><br></pre></td></tr></table></figure>\n\n<p>这里面 3 表示数组中元素的长度。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>); <span class=\"comment\">//[2,3,4]</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>Array()</code>里的参数个数大于 1 的时候，表示的是数组元素。</p>\n<p><code>Array.of()</code>方法不管里面参数的个数多少，都将其转为数组的元素。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[3]</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><h4 id=\"1-对象中有关变量的解构赋值\"><a href=\"#1-对象中有关变量的解构赋值\" class=\"headerlink\" title=\"1.对象中有关变量的解构赋值\"></a>1.对象中有关变量的解构赋值</h4><p>解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; name, work &#125; = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;lagou&quot;</span>, <span class=\"attr\">work</span>: <span class=\"string\">&quot;web&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name, work); <span class=\"comment\">//lagou web</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-对象的扩展\"><a href=\"#2-对象的扩展\" class=\"headerlink\" title=\"2.对象的扩展\"></a>2.对象的扩展</h4><ul>\n<li><p>对象的简写</p>\n<ul>\n<li><p>当变量名和属性名同名式，省略同名的属性值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123; foo &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> baz = &#123; <span class=\"attr\">foo</span>: foo &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>省略方法中的 function</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  method() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;拉勾!&quot;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;拉勾!&quot;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>属性的赋值器（setter）和取值器（getter）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lagou = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;拉勾&quot;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">com</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">work</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = <span class=\"built_in\">this</span>.name + value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lagou.com); <span class=\"comment\">//拉勾</span></span><br><span class=\"line\">lagou.work = <span class=\"string\">&quot;招聘&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lagou.name); <span class=\"comment\">//拉勾招聘</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>属性名表达式</p>\n<p>es5 中定义对象的属性有两种方法，一种是用标识符做属性，一种是用表达式做属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法一;</span><br><span class=\"line\">obj.name = <span class=\"string\">&quot;拉勾&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\">obj[<span class=\"string\">&quot;name&quot;</span>] = <span class=\"string\">&quot;拉勾&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> lagou = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;拉勾&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果使用大括号定义对象，那么在 es5 中只能使用标识符定义属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lagou = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;拉勾&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>但是 ECMAScript2015 在使用大括号定义对象的时候，允许使用表达式定义属性，把表达式放在方括号中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name = <span class=\"string\">&quot;lagou&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> lagou = &#123;</span><br><span class=\"line\">  [name]: <span class=\"string\">&quot;web&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lagou); <span class=\"comment\">//&#123;lagou: &quot;web&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-三点运算在对象中的用途\"><a href=\"#3-三点运算在对象中的用途\" class=\"headerlink\" title=\"3.三点运算在对象中的用途\"></a>3.三点运算在对象中的用途</h4><ul>\n<li><p>用于对象的解构</p>\n<ul>\n<li><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; x, y, ...z &#125; = &#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">a</span>: <span class=\"number\">3</span>, <span class=\"attr\">b</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(z); <span class=\"comment\">//&#123;a: 3, b: 4&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p>\n<pre><code>注意:1.解构赋值必须是最后一个参数。2.解构赋值的拷贝是浅拷贝。</code></pre>\n</li>\n</ul>\n</li>\n<li><p>用于扩展运算</p>\n<ul>\n<li><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> z = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;lagou&quot;</span>, <span class=\"attr\">work</span>: <span class=\"string\">&quot;web&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n = &#123; ...z &#125;;</span><br><span class=\"line\">n; <span class=\"comment\">// &#123; name: &quot;lagou&quot;, work: &quot;web&quot; &#125;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><h4 id=\"1-字符串模板\"><a href=\"#1-字符串模板\" class=\"headerlink\" title=\"1.字符串模板\"></a>1.字符串模板</h4><ul>\n<li><p>传统的字符串里不能使用换行符，必须使用转义符\\n 替代，字符串模板里可以使用。模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>\n</li>\n<li><p>模板字符串中嵌入变量，需要将变量名写在<code>$&#123;&#125;</code>之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&quot;拉勾&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"string\">`欢迎来到<span class=\"subst\">$&#123;name&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(st);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"2-标签模板\"><a href=\"#2-标签模板\" class=\"headerlink\" title=\"2.标签模板\"></a>2.标签模板</h4><ul>\n<li><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log<span class=\"string\">`hello`</span>;</span><br><span class=\"line\">等同于;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"string\">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure>\n\n<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>\n<p>注意:如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">&quot;laogou&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> work=<span class=\"string\">&quot;web&quot;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tag</span>(<span class=\"params\">st,a,b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(st);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(b)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello lagou&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> st=tag<span class=\"string\">`hello<span class=\"subst\">$&#123;name&#125;</span>,职业<span class=\"subst\">$&#123;work&#125;</span>开发`</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(st)<span class=\"comment\">//hello lagou</span></span><br><span class=\"line\">[<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;,职业&quot;</span>, <span class=\"string\">&quot;开发&quot;</span>, <span class=\"attr\">raw</span>: <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>)]</span><br><span class=\"line\">laogou</span><br><span class=\"line\">web</span><br></pre></td></tr></table></figure>\n\n<p>函数内的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">&quot;laogou&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> work = <span class=\"string\">&quot;web&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tag</span>(<span class=\"params\">st, a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(st);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello lagou&quot;</span>; <span class=\"comment\">//如果没有返回值，则默认是undefined</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> st = tag<span class=\"string\">`hello<span class=\"subst\">$&#123;name&#125;</span>,职业<span class=\"subst\">$&#123;work&#125;</span>开发`</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(st); <span class=\"comment\">//hello lagou</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"3-扩展的方法\"><a href=\"#3-扩展的方法\" class=\"headerlink\" title=\"3.扩展的方法\"></a>3.扩展的方法</h4><ul>\n<li><p>字符串实例的方法</p>\n<ul>\n<li><p><strong>includes()</strong></p>\n<p>返回布尔值，表示是否找到了参数字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"string\">&quot;lagou web&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = st.includes(<span class=\"string\">&quot;web&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>startsWith()</strong></p>\n<p>返回布尔值，表示参数字符串是否在原字符串的头部</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"string\">&quot;lagou web&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = st.startsWith(<span class=\"string\">&quot;la&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>endsWith()</strong></p>\n<p>返回布尔值，表示参数字符串是否在原字符串的尾部</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"string\">&quot;lagou web&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = st.endsWith(<span class=\"string\">&quot;web&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><h4 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h4><ul>\n<li><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a, b = <span class=\"string\">&quot; lagou &quot;</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(<span class=\"string\">&quot;hello&quot;</span>); <span class=\"comment\">//hello lagou</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意:</p>\n<ul>\n<li>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明.</li>\n<li>使用参数默认值时，函数不能有同名参数</li>\n</ul>\n</li>\n<li><p>参数默认值的位置</p>\n<ul>\n<li><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x = <span class=\"number\">1</span>, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// [1, undefined]</span></span><br><span class=\"line\">f(<span class=\"number\">2</span>) <span class=\"comment\">// [2, undefined]</span></span><br><span class=\"line\">f(, <span class=\"number\">1</span>) <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"rest-参数\"><a href=\"#rest-参数\" class=\"headerlink\" title=\"rest 参数\"></a><span name=\"app\">rest 参数</span></h4><ul>\n<li><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">...values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(values);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>); <span class=\"comment\">// [2, 5, 3]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>rest 参数和函数中的参数解构有什么区别</p>\n<ul>\n<li>rest 参数是发生在函数的定义阶段，函数的额参数解构是发生在函数的调用阶段</li>\n<li>二者是一种互为逆运算</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">...values</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这是rest参数</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(values);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>); <span class=\"comment\">// [2, 5, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a + b + c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(...arr); <span class=\"comment\">//6  这是参数的解构</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><ul>\n<li>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> v;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\">() =&gt;</span> <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\">(<span class=\"params\">num1, num2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num1 + num2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> getItem = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> &#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">name</span>: <span class=\"string\">&quot;Temp&quot;</span> &#125;; <span class=\"comment\">//报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> getItem = <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> (&#123; <span class=\"attr\">id</span>: id, <span class=\"attr\">name</span>: <span class=\"string\">&quot;Temp&quot;</span> &#125;);<span class=\"comment\">//不报错</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>箭头函数有几个使用注意点<ul>\n<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。箭头函数外面的 this 是什么，箭头函数内的 this 还是什么。</li>\n<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li>\n<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">&quot;web&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">    name:<span class=\"string\">&quot;lagou&quot;</span>,</span><br><span class=\"line\">    fn()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t=<span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)<span class=\"comment\">//web  this是window</span></span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.fn()</span><br><span class=\"line\">-----------------------------------</span><br><span class=\"line\"><span class=\"keyword\">var</span> name=<span class=\"string\">&quot;web&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj=&#123;</span><br><span class=\"line\">    name:<span class=\"string\">&quot;lagou&quot;</span>,</span><br><span class=\"line\">    fn()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t=<span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name)<span class=\"comment\">//lagou this是obj</span></span><br><span class=\"line\">        &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.fn()</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><h4 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h4><ul>\n<li><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">123</span>,</span><br><span class=\"line\">  b: <span class=\"number\">123</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> sourcel = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">456</span>,</span><br><span class=\"line\">  c: <span class=\"number\">456</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = <span class=\"built_in\">Object</span>.assign(target, sourcel);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target); <span class=\"comment\">//&#123;a: 456, b: 123, c: 456&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target === result); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果目标对象与源对象有同名属性，则后面的属性会覆盖前面的属性。且<code>assign()</code>的返回值就是第一个对象。</p>\n<p>如果有多个源对象有同名属性，依然是后面的会覆盖前面的属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> target = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source1 = &#123; <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">2</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source2 = &#123; <span class=\"attr\">c</span>: <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(target, source1, source2);</span><br><span class=\"line\">target; <span class=\"comment\">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>利用<code>Object.assign()</code>复制一个对象，且其中一个对象的修改不会影响到另一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sourcel = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">123</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, sourcel);</span><br><span class=\"line\">obj.a = <span class=\"number\">456</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">//&#123;a: 456&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sourcel); <span class=\"comment\">//&#123;a: 123&#125;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a>Object.is()</h4><ul>\n<li><p><code>Object.is</code>就是用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(+<span class=\"number\">0</span>, <span class=\"number\">-0</span>)); <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"number\">0</span> === <span class=\"number\">-0</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h1><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Proxy 可以理解成一个快递员，我们发快递还是接受快递，都需要这个快递员充当一个代理的作用。ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例，这个实例就是一个代理对象（快递员）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"目标对象\"><a href=\"#目标对象\" class=\"headerlink\" title=\"目标对象\"></a>目标对象</h4><p>这个代理对象有两个参数，一个是代理的目标对象，第二个也是一个对象，它是配置对象，用来定制代理的拦截行为。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;zce&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> personProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(person, &#123;</span><br><span class=\"line\">  get(target, property) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(target, property); <span class=\"comment\">//person&#123;name:&quot;zce&quot;,age:20&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set() &#123;&#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置对象\"><a href=\"#配置对象\" class=\"headerlink\" title=\"配置对象\"></a>配置对象</h4><ul>\n<li><p>配置对象中一般有两个方法<code>get</code>和<code>set</code>,<code>get</code>是用来拦截对目标对象属性的访问请求。<code>get</code>方法中有两个参数，第一个参数是目标对象，第二个参数是访问的那个属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;zce&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> personProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(person, &#123;</span><br><span class=\"line\">  get(target, property) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(target, property);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set() &#123;&#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(personProxy.name); <span class=\"comment\">//100</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>注意，这个<code>get</code>方法的返回值就是我们获取的这个属性的返回值。</p>\n<ul>\n<li><p>这个<code>get</code>方法中有三个参数，一个是代理的目标对象，一个是代理的处理对象，第三个参数是 proxy 实例本身，且第三个参数是可选参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;zce&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> personProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(person, &#123;</span><br><span class=\"line\">  get(target, property, o) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(o); <span class=\"comment\">//proxy&#123;name:&quot;zec&quot;,age:20&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> property <span class=\"keyword\">in</span> target ? target[property] : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set() &#123;&#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(personProxy.age); <span class=\"comment\">//20</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这个<code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;zce&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> personProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(person, &#123;</span><br><span class=\"line\">  get(target, property, o) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> property <span class=\"keyword\">in</span> target ? target[property] : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set(obj, pro, value, o) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(obj, pro, value, o);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((personProxy.name = <span class=\"string\">&quot;zhang&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//&#123;name: &quot;zce&quot;, age: 20&#125; &quot;name&quot; &quot;zhang&quot; Proxy &#123;name: &quot;zce&quot;, age: 20&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以去设置一些属性或修改</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;zce&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">20</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> personProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(person, &#123;</span><br><span class=\"line\">  get(target, property, o) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> property <span class=\"keyword\">in</span> target ? target[property] : <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set(target, pro, value, o) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//可以做一些内部校验</span></span><br><span class=\"line\">    target[pro] = value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((personProxy.name = <span class=\"string\">&quot;lagou&quot;</span>));</span><br><span class=\"line\">person; <span class=\"comment\">//&#123;name:&quot;lagou&quot;,age:20&#125;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"Reflect\"><a href=\"#Reflect\" class=\"headerlink\" title=\"Reflect\"></a>Reflect</h1><h4 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\n<ul>\n<li><p>将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法</p>\n</li>\n<li><p>修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(target, property, attributes);</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"string\">&quot;assign&quot;</span> <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.has(<span class=\"built_in\">Object</span>, <span class=\"string\">&quot;assign&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h4><ul>\n<li><p>Reflect.get</p>\n<ul>\n<li><p><code>Reflect.get(target, name, receiver)</code>,<code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">baz</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.foo + <span class=\"built_in\">this</span>.bar;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(myObject, <span class=\"string\">&quot;foo&quot;</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(myObject, <span class=\"string\">&quot;bar&quot;</span>); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(myObject, <span class=\"string\">&quot;baz&quot;</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">baz</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.foo + <span class=\"built_in\">this</span>.bar;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myReceiverObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">4</span>,</span><br><span class=\"line\">  bar: <span class=\"number\">4</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(myObject, <span class=\"string\">&quot;baz&quot;</span>, myReceiverObject); <span class=\"comment\">// 8</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(<span class=\"number\">1</span>, <span class=\"string\">&quot;foo&quot;</span>); <span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.get(<span class=\"literal\">false</span>, <span class=\"string\">&quot;foo&quot;</span>); <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Reflect.set</p>\n<ul>\n<li><p><code>Reflect.set(target, name, value, receiver)</code>,<code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.foo; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.set(myObject, <span class=\"string\">&quot;foo&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">myObject.foo; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">4</span>,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">bar</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">this</span>.foo = value);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myReceiverObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">0</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.set(myObject, <span class=\"string\">&quot;bar&quot;</span>, <span class=\"number\">1</span>, myReceiverObject);</span><br><span class=\"line\">myObject.foo; <span class=\"comment\">// 4</span></span><br><span class=\"line\">myReceiverObject.foo; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>Reflect.has</p>\n<ul>\n<li><p><code>Reflect.has(obj, name)</code>,<code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 旧写法</span></span><br><span class=\"line\"><span class=\"string\">&quot;foo&quot;</span> <span class=\"keyword\">in</span> myObject; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.has(myObject, <span class=\"string\">&quot;foo&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p>\n</li>\n</ul>\n</li>\n<li><p>Reflect.deleteProperty</p>\n<ul>\n<li><p>Reflect.deleteProperty(obj, name),<code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myObj = &#123; <span class=\"attr\">foo</span>: <span class=\"string\">&quot;bar&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 旧写法</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> myObj.foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.deleteProperty(myObj, <span class=\"string\">&quot;foo&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h1><h4 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\n<p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n<h4 id=\"promise-特点\"><a href=\"#promise-特点\" class=\"headerlink\" title=\"promise 特点\"></a>promise 特点</h4><p><code>Promise</code>对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>\n<h4 id=\"promise-使用方法\"><a href=\"#promise-使用方法\" class=\"headerlink\" title=\"promise 使用方法\"></a>promise 使用方法</h4><ul>\n<li><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p>\n</li>\n<li><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    resolve(data);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>\n</li>\n<li><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.then(</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// success业务处理</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// failure</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p>\n<ul>\n<li><p>看一个简单的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">time</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">time(<span class=\"number\">1000</span>).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>Promise 新建后就会立即执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Promise&quot;</span>);</span><br><span class=\"line\">  resolve();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;resolved.&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Hi!&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//Promise</span></span><br><span class=\"line\"><span class=\"comment\">//Hi</span></span><br><span class=\"line\"><span class=\"comment\">//resolved</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h1><h4 id=\"概述-3\"><a href=\"#概述-3\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;(&quot;</span> + <span class=\"built_in\">this</span>.x + <span class=\"string\">&quot;, &quot;</span> + <span class=\"built_in\">this</span>.y + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h4><ul>\n<li><p><code>constructor()</code></p>\n<ul>\n<li><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</li>\n</ul>\n</li>\n<li><p>类的实例</p>\n<ul>\n<li><p>生成类的实例的写法，与 ES5 完全一样，也是使用<code>new</code>命令。前面说过，如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;(&quot;</span> + <span class=\"built_in\">this</span>.x + <span class=\"string\">&quot;, &quot;</span> + <span class=\"built_in\">this</span>.y + <span class=\"string\">&quot;)&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> point = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">point.toString(); <span class=\"comment\">// (2, 3)</span></span><br><span class=\"line\"></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">&quot;x&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">&quot;y&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">point.hasOwnProperty(<span class=\"string\">&quot;toString&quot;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\">point.__proto__.hasOwnProperty(<span class=\"string\">&quot;toString&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>与 ES5 一样，类的所有实例共享一个原型对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">3</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">p1.__proto__ === p2.__proto__;</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>getter 和 setter</p>\n<ul>\n<li><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">prop</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;getter&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">prop</span>(<span class=\"params\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;setter: &quot;</span> + value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> inst = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"></span><br><span class=\"line\">inst.prop = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"comment\">// setter: 123</span></span><br><span class=\"line\"></span><br><span class=\"line\">inst.prop;</span><br><span class=\"line\"><span class=\"comment\">// &#x27;getter&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>属性表达式</p>\n<ul>\n<li><p>类的属性名，可以采用表达式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> methodName = <span class=\"string\">&quot;getArea&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(length) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [methodName]() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h4><ul>\n<li><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.classMethod(); <span class=\"comment\">// &#x27;hello&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">foo.classMethod();</span><br><span class=\"line\"><span class=\"comment\">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>\n\n<p>解说：上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>\n</li>\n<li><p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> bar() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.baz();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> baz() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  baz() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.bar(); <span class=\"comment\">// hello</span></span><br></pre></td></tr></table></figure>\n\n<p>解说：上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p>\n</li>\n<li><p>父类的静态方法，可以被子类继承</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> classMethod() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Foo</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Bar.classMethod(); <span class=\"comment\">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>静态属性</p>\n<p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性</p>\n<p>ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a href=\"https://github.com/tc39/proposal-class-fields\">提案</a>提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> myStaticProp = <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(MyClass.myStaticProp); <span class=\"comment\">// 42</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><ul>\n<li><p>简介</p>\n<ul>\n<li><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解说：上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类</p>\n</li>\n<li><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> cp = <span class=\"keyword\">new</span> ColorPoint(); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ColorPoint</span> <span class=\"keyword\">extends</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y, color) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = color; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">    <span class=\"built_in\">super</span>(x, y);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.color = color; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>super</p>\n<ul>\n<li><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同</p>\n<ul>\n<li><p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解说：上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B的实例，因此</code>super()<code>在这里相当于</code>A.prototype.constructor.call(this)`</p>\n</li>\n<li><p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  p() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">super</span>.p()); <span class=\"comment\">// 2</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由于<code>super</code>指向父类的原型对象(prototype)，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.p = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">m</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">b.m; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h1><h4 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><ul>\n<li><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>\n</li>\n<li><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p>\n</li>\n<li><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set); <span class=\"comment\">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>数组去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...new <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])]; <span class=\"comment\">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串去重</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...new <span class=\"built_in\">Set</span>(<span class=\"string\">&quot;ababbc&quot;</span>)].join(<span class=\"string\">&quot;&quot;</span>); <span class=\"comment\">//&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"属性和方法\"><a href=\"#属性和方法\" class=\"headerlink\" title=\"属性和方法\"></a>属性和方法</h4><ul>\n<li><p>Set 结构的实例有以下属性。</p>\n<ul>\n<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>\n<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>\n</ul>\n</li>\n<li><p>Set 实例的方法分为两大类</p>\n<ul>\n<li><p>操作方法（用于操作数据）</p>\n<ul>\n<li><p><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([]);</span><br><span class=\"line\">items.add(<span class=\"number\">1</span>).add(<span class=\"number\">2</span>).add(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir(items); <span class=\"comment\">//[1,2,3]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">12</span>, <span class=\"number\">23</span>, <span class=\"number\">34</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = items.delete(<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items); <span class=\"comment\">//Set(2) &#123;23, 34&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</p>\n</li>\n<li><p><code>Set.prototype.clear()</code>：清除所有成员，没有返回值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> items = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">12</span>, <span class=\"number\">23</span>, <span class=\"number\">34</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = items.clear(<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(items); <span class=\"comment\">//Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>遍历方法（用于遍历成员）</p>\n<ul>\n<li><p><code>Set.prototype.keys()</code>：返回键名的遍历器</p>\n</li>\n<li><p><code>Set.prototype.values()</code>：返回键值的遍历器</p>\n</li>\n<li><p>Set.prototype.entries()</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">&quot;red&quot;</span>, <span class=\"string\">&quot;green&quot;</span>, <span class=\"string\">&quot;blue&quot;</span>]);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// red</span></span><br><span class=\"line\"><span class=\"comment\">// green</span></span><br><span class=\"line\"><span class=\"comment\">// blue</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> set.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Set.prototype.forEach()</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>]);</span><br><span class=\"line\">set.forEach(<span class=\"function\">(<span class=\"params\">value, key</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(key + <span class=\"string\">&quot; : &quot;</span> + value));</span><br><span class=\"line\"><span class=\"comment\">// 1 : 1</span></span><br><span class=\"line\"><span class=\"comment\">// 4 : 4</span></span><br><span class=\"line\"><span class=\"comment\">// 9 : 9</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h1><h4 id=\"概述-4\"><a href=\"#概述-4\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<h4 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><ul>\n<li><p>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&quot;title&quot;</span>, <span class=\"string\">&quot;Author&quot;</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">map.has(<span class=\"string\">&quot;name&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.get(<span class=\"string\">&quot;name&quot;</span>); <span class=\"comment\">// &quot;张三&quot;</span></span><br><span class=\"line\">map.has(<span class=\"string\">&quot;title&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">map.get(<span class=\"string\">&quot;title&quot;</span>); <span class=\"comment\">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"属性和方法-1\"><a href=\"#属性和方法-1\" class=\"headerlink\" title=\"属性和方法\"></a>属性和方法</h4><ul>\n<li><p>size 属性，<code>size</code>属性返回 Map 结构的成员总数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;foo&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;bar&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map.prototype.set(key, value) <code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键， set()方法返回的是 set 对象可以采用链式写法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(<span class=\"string\">&quot;edition&quot;</span>, <span class=\"number\">6</span>); <span class=\"comment\">// 键是字符串</span></span><br><span class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">&quot;standard&quot;</span>); <span class=\"comment\">// 键是数值</span></span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>); <span class=\"comment\">// 键是 undefined</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map.prototype.get(key) <code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> hello = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">m.set(hello, <span class=\"string\">&quot;Hello ES6!&quot;</span>); <span class=\"comment\">// 键是函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.get(hello); <span class=\"comment\">// Hello ES6!</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map.prototype.has(key)<code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">m.set(<span class=\"string\">&quot;edition&quot;</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">m.set(<span class=\"number\">262</span>, <span class=\"string\">&quot;standard&quot;</span>);</span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">m.has(<span class=\"string\">&quot;edition&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(<span class=\"string\">&quot;years&quot;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\">m.has(<span class=\"number\">262</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>Map.prototype.delete(key)<code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> m = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">m.set(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;nah&quot;</span>);</span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">m.delete(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\">m.has(<span class=\"literal\">undefined</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map.prototype.clear()<code>clear</code>方法清除所有成员，没有返回值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;foo&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">&quot;bar&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">map.size; <span class=\"comment\">// 2</span></span><br><span class=\"line\">map.clear();</span><br><span class=\"line\">map.size; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><ul>\n<li><p><code>Map.prototype.keys()</code>：返回键名的遍历器。</p>\n</li>\n<li><p><code>Map.prototype.values()</code>：返回键值的遍历器</p>\n</li>\n<li><p><code>Map.prototype.entries()</code>：返回所有成员的遍历器</p>\n</li>\n<li><p><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"string\">&quot;F&quot;</span>, <span class=\"string\">&quot;no&quot;</span>],</span><br><span class=\"line\">  [<span class=\"string\">&quot;T&quot;</span>, <span class=\"string\">&quot;yes&quot;</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">of</span> map.keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;F&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;T&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> map.values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;no&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;yes&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> map.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(item[<span class=\"number\">0</span>], item[<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;F&quot; &quot;no&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// &quot;F&quot; &quot;no&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class=\"line\">map.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value, key, map</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p>\n</li>\n</ul>\n<h1 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h1><h4 id=\"概述-5\"><a href=\"#概述-5\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  say: <span class=\"string\">&quot;lagou&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> say = <span class=\"built_in\">Symbol</span>(); <span class=\"comment\">//say 是symbol类型</span></span><br><span class=\"line\">obj[say] = <span class=\"string\">&quot;web&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj); <span class=\"comment\">//&#123;say: &quot;lagou&quot;, Symbol(): &quot;web&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><ul>\n<li><p><code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错</p>\n</li>\n<li><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分</p>\n</li>\n<li><p>每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a === b); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Symbol 值不能与其他类型的值进行运算，会报错</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;My symbol&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;your symbol is &quot;</span> +</span><br><span class=\"line\">  sym <span class=\"comment\">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class=\"line\">  <span class=\"string\">`your symbol is <span class=\"subst\">$&#123;sym&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"comment\">// TypeError: can&#x27;t convert symbol to string</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Symbol 值作为对象属性名时，不能用点运算符</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mySymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = &#123;&#125;;</span><br><span class=\"line\">a.mySymbol = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[mySymbol]); <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[<span class=\"string\">&quot;mySymbol&quot;</span>]); <span class=\"comment\">//hello</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">obj[a] = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">obj[b] = <span class=\"string\">&quot;World&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> objectSymbols = <span class=\"built_in\">Object</span>.getOwnPropertySymbols(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(objectSymbols); <span class=\"comment\">//[Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> s1 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> s2 = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">s1 === s2; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;bar&quot;</span>) === <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;bar&quot;</span>) === <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> x = foo();</span><br><span class=\"line\"><span class=\"keyword\">const</span> y = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x === y); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"可迭代接口\"><a href=\"#可迭代接口\" class=\"headerlink\" title=\"可迭代接口\"></a>可迭代接口</h1><h4 id=\"Iterater-的概念\"><a href=\"#Iterater-的概念\" class=\"headerlink\" title=\"Iterater 的概念\"></a>Iterater 的概念</h4><ul>\n<li><p>简单介绍</p>\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\n<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>\n<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p>\n</li>\n<li><p>Iterator 的遍历过程</p>\n<ul>\n<li><p>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>\n</li>\n<li><p>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员</p>\n</li>\n<li><p>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员</p>\n</li>\n<li><p>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置</p>\n<p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单的Iterator遍历器的实现;</span><br><span class=\"line\"><span class=\"keyword\">var</span> it = easyIterator([<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class=\"line\">it.next(); <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">easyIterator</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nextIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    next: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextIndex &lt; array.length</span><br><span class=\"line\">        ? &#123; <span class=\"attr\">value</span>: array[nextIndex++], <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">        : &#123; <span class=\"attr\">value</span>: <span class=\"literal\">undefined</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Iterater-接口\"><a href=\"#Iterater-接口\" class=\"headerlink\" title=\"Iterater 接口\"></a>Iterater 接口</h4><ul>\n<li><p>字符串 数组 set map arguments 都有 iterater 接口，nodelist 集合，都可以用 for of 遍历</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> st = <span class=\"string\">&quot;lagou&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> st) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// l a g o u</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (v <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v); <span class=\"comment\">//1 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> <span class=\"built_in\">arguments</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">//1 2 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fn(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h1><h4 id=\"概述-6\"><a href=\"#概述-6\" class=\"headerlink\" title=\"概述\"></a>概述</h4><ul>\n<li>JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li>\n</ul>\n<h4 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h4><ul>\n<li><p>export</p>\n<ul>\n<li><p><code>export</code>命令用于规定模块的对外接口</p>\n</li>\n<li><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> firstName = <span class=\"string\">&quot;Michael&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> lastName = <span class=\"string\">&quot;Jackson&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> year = <span class=\"number\">1958</span>;</span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstName = <span class=\"string\">&quot;Michael&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> lastName = <span class=\"string\">&quot;Jackson&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> year = <span class=\"number\">1958</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>import</p>\n<ul>\n<li><p><code>import</code>命令用于输入其他模块提供的功能</p>\n</li>\n<li><p><code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; firstName, lastName, year &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./profile.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setName</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">  element.textContent = firstName + <span class=\"string\">&quot; &quot;</span> + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>-</p>\n</li>\n<li><p>export default</p>\n<ul>\n<li><p>为了给用户提供方便，就要用到<code>export default</code>命令，为模块指定默认输出</p>\n</li>\n<li><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字</p>\n</li>\n<li><p>在<code>import</code>命令后面，不再使用大括号</p>\n</li>\n<li><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// export-default.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// import-default.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> customName <span class=\"keyword\">from</span> <span class=\"string\">&quot;./export-default&quot;</span>;</span><br><span class=\"line\">customName(); <span class=\"comment\">// &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"浏览器端加载实现\"><a href=\"#浏览器端加载实现\" class=\"headerlink\" title=\"浏览器端加载实现\"></a>浏览器端加载实现</h4><ul>\n<li><p>浏览器加载 ES6 模块，也使用标签，但是要加入<code>type=&quot;module&quot;</code>属性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 01.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> a = <span class=\"number\">123</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//demo.html</span></span><br><span class=\"line\">&lt;script type=<span class=\"string\">&quot;module&quot;</span>&gt;<span class=\"keyword\">import</span> &#123;a&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./01.js&quot;</span>; <span class=\"built_in\">console</span>.log(a)<span class=\"comment\">//123&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>脚本异步加载</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;path/to/myModule.js&quot;</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;path/to/myModule.js&quot;</span> <span class=\"attr\">async</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解说：上面代码中，标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。defer 与 async 的区别是：defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。另外，如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。</p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckdzwln0g0000lnlgcrxie09b","category_id":"ckdzoqe000000mqlgbb9643ny","_id":"ckdzx18g00001eflgc5eub6k4"},{"post_id":"ckf9f34bn000045lg3bnn0zxe","category_id":"ckf9f34do000145lg57hxdrgu","_id":"ckf9f73o50001zulg2iik37f2"}],"PostTag":[{"post_id":"ckdzwln0g0000lnlgcrxie09b","tag_id":"ckdzwmooc0000pvlgfdsx3pdx","_id":"ckdzx18fz0000eflg4ogb0lex"},{"post_id":"ckf9f34bn000045lg3bnn0zxe","tag_id":"ckdzwmooc0000pvlgfdsx3pdx","_id":"ckf9f73o50000zulg14do9vco"}],"Tag":[{"name":"Markdown","_id":"ckdzoqe000001mqlgfqmj0fap"},{"name":"js","_id":"ckdzwmooc0000pvlgfdsx3pdx"},{"name":"test","_id":"ckf3cpfgk0002wwlg010tgxr6"}]}}